\documentclass[10pt,a4paper,oneside]{book}

%Hello there. Don't know what to do?
	%Search for the %? or \fixme and fix/add stuff.
	%Check zapiski 2007, your notes and your memory and fix/add stuff
	%kul knjige imajo quote na začetku poglavij
%
%lol, windows newline bug poje to vrsto na začetku včasih :P
%\documentclass[10pt,a4paper,oneside]{book}

\usepackage[slovene]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[fleqn]{amsmath}%fleqn - levo zamaknjene enačbe
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage[x11names, rgb]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc,automata,snakes,arrows,shapes,decorations,positioning,shapes.arrows,chains,shadows}

\usepackage{torstyle}
%?this feels too much like CSS hacks :(
%torstlye predloge:
%Definicija \Def{}
%Primer \Primer{}
%Prirejen itemize \begin{items}
\hypersetup{pdftitle={Teoreticne osnove racunalnistva}}

\begin{document}
\begin{titlepage}
\begin{center}
%looks useful
%{\resizebox{15cm}{!}{Teoretične osnove računalništva}}\\[5pt]
\ \\[1cm]
{\Huge\bf Teoreti\v cne osnove ra\v cunalni\v stva}\\[1cm]
{\huge \today}\ \\[1.55cm]
%{\LARGE Zapiski predavanj 2010/2011}\\[15pt]%Odkar sem dodal kontekstno-odvisne in linearne, to ni več samo to :P
\begin{tikzpicture}[scale=1.35, very thick, circ/.style={thin}]%?tole ful upočasni pdflatex%, decorate, decoration={snake, amplitude=0.75pt}}]
	\draw [rounded corners=10pt] (-5.4cm,-5.4cm) rectangle (5.4cm,5.4cm);
	\node at (4.5cm,4.7cm) {\Large $\mathcal{P}(\Sigma^*)$};%sva šla vprašat... ker \Sigma^* znajo že RJ opisat, samo ne vseh možnih ;)

	%\draw[circ] (0cm,0cm) circle (5cm);
	%\node at (0,4cm) {\large\bf \nameref{chap:Turingovi jeziki}};

	\draw[circ] (0cm,-0.8cm) circle (4cm);
	\node at (0,2cm) {\large\bf \nameref{chap:Turingovi jeziki}};
	%\node at (0,2cm) {\large\bf \nameref{chap:Kontekstno-odvisni jeziki}};

	\draw[circ] (0cm,-1.6cm) circle (3cm);
	\node at (0,0cm) {\large\bf \nameref{chap:Kontekstno-neodvisni jeziki}};

	\draw[circ] (0cm,-2.4cm) circle (2cm);
	\node at (0,-2cm) {\large\bf \nameref{chap:Regularni jeziki}};
\end{tikzpicture}

\vfill
\parbox{7.5cm}{
\begin{center}
\includegraphics[width=0.15\textwidth]{./by-nc-sa}\\[6pt]

This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
\end{center}
}

\end{center}
\end{titlepage}
\tableofcontents
\pagebreak

\include{poglavja/Uvod}
\include{poglavja/RegularniJeziki}
%\include{poglavja/LinearniJeziki}
\include{poglavja/KontekstnoNeodvisniJeziki}
%\include{poglavja/KontekstnoOdvisniJeziki}

%--------------------------------TOR2 line--------------------------------------

\chap{Turingovi jeziki}
\sect{Zgodovina}
%I've got 23 problems, but a bitch ain't one. -Hilbert, 1900
%\br
Leta 1900 je Nemški matematik David Hilbert objavil seznam triindvajsetih nerešenih problemov v matematiki. Eden izmed Hilbertovih problemov (deseti po vrsti), je vprašanje, ali obstaja postopek, po katerem ugotovimo rešljivost poljubne Diofantske enačbe -- torej, ali lahko ugotovimo, če ima polinom s celoštevilskimi koeficienti $P(x_1, x_2, \dots, x_n)=0$, celoštevilsko rešitev.
%?več zgodovine tu :)
Kljub temu, da je Emil Post že leta 1944 slutil, da je problem nerešljiv, je to dokončno dokazal rus Jurij Matijaševič šele leta 1970 v svojem doktorskem delu. Med reševanjem problema pa so se matematiki že prej začeli ukvarjati s formalizacijo pojma postopka oz. algoritma. Intuitivna definicija tega se glasi nekako tako:
\Def{Algoritem je zaporedje ukazov, s katerimi se v končnem številu korakov opravi neka naloga.}
Pri tem pa ostaja še kar nekaj odprtih vprašanj, npr.:
\begin{items}
\item Kakšni naj bodo ukazi? 
	\begin{items}
	\item Osnovni - algoritem ima veliko korakov
	\item Kompleksni - prezapleteni ukazi so že sami algoritmi
	\end{items}
\item Koliko ukazov naj bo?
	\begin{items}
	\item Končno - ali je s končno množico res mogoče rešiti vsako nalogo?
	\item Neskončno - kakšen izvajalec ukazov je sposoben izvršiti neskončno različnih ukazov?
	\end{items}
\item So ukazi zvezni ali diskretni?
\item V kakšnem pomnilniku so ukazi shranjeni?
	\begin{items}%?verjetno ista vprašanja kot pri št. ukazov?
	\item Končnem - ali s končnim zaporedjem ukazov res lahko mogoče rešimo vsako nalogo?
	\item Neskončnem - \fixme%?
	\end{items}
\end{items}
Nekateri zgodnji poskusi formalizacije pojma algoritma so:%? zgodovinsko zaporedje, letnice, imena modelov, moar info
\begin{items}
    \item Rekurzivne funkcije (Kurt Gödel, Stephen Kleene) 
    \item Splošne rekurzivne funkcije (Jacques Herbrand, Kurt Gödel)
    \item Algoritmi Markova (Andrey Markov, ml.), %sin Markova http://en.wikipedia.org/wiki/Andrey_Markov_(Soviet_mathematician)
    \item Produkcijski sistem (Emil Post), %? je to http://en.wikipedia.org/wiki/Tag_system? 1943?
    \item Lambda račun (Alonso Church, 1936)
    \item Turingov stroj (Alan Turing, 1936)
\end{items}

\pagebreak
\sect{Turingovi stroji}
Turingov stroj se je uveljavil kot uporaben in preprost model računanja, ki zna izračunati vse kar se izračunati da (pod pogojem, da Church-Turingova teza drži). Alan Turing je svoj stroj izpeljal iz razmišljanja o tem, kako človek rešuje miselne probleme na papir. Pri tem je izbral tri sestavne dele:
\begin{items}
\item Nadzorno enoto (glava)
\item Čitalno okno (roka in vid)
\item Trak (papir)
\end{items}
V postopku formalizacije, pa je zaradi večje preprostosti, zahteval še, da je stroj sestavljen iz končno mnogo elementov, ter da deluje v diskretnih korakih.%?končno mnogo elementov? na kaj to cilja?
\ \\
\begin{center}
\begin{tikzturing}
	\node [on chain=trak] {Trak};
	\foreach \x in {1,2,...,5} {
		\node [cell] {$A_{\x}$};
	}
	\node      [cell]           {\ ...\ \ };
	\node (Ai) [cell, selected] {$A_i$};
	\node      [cell]           {\ ...\ \ };
	\node      [cell]           {$A_n$};
	\node      [cell]           {\color{gray}$B$};
	\node      [cell]           {\color{gray}$B$};
	\node      [cell]           {\ ...\ \ };
	\node      [cell, end]      {};

	%?must be a better way, zadnja črta niti ni naravnost
	\node (ne) at (110bp, 70bp) [head, minimum height=1.4cm, minimum width=3cm]  {Nadzorna enota};
	\draw (ne.south) -- (110bp, 25bp) -- (137.5bp, 25bp) [->] to (Ai.north);
	\node [below] at (Ai.south) {Čitalno okno};
\end{tikzturing}
\end{center}

\Def{Turingov stroj je definiran kot sedmerka $M=\langle Q, \Sigma, \Gamma, \delta, q_0, B, F \rangle $, kjer je:
\begin{items}
	\item $Q$ končna množica stanj
	\item $\Sigma$ končna množica vhodnih simbolov, $Q \cap \Sigma = \emptyset$
	\item $\Gamma$ končna množica tračnih simbolov, $\Sigma \subset \Gamma$
	\item $\delta$ funkcija prehodov: $Q \times \Gamma \rightarrow Q \times \Gamma \times \{L,D\}$,\\ kjer $L$ in $D$ označujeta premik levo ali desno
	\item $q_0$ začetno stanje, $q_0 \in Q$
	\item $B$ prazen simbol, $B \in \Gamma$
	\item $F$ množica končnih stanj, $F \subseteq Q$ 
\end{items}}
Stroj deluje tako, da v vsakem koraku opravi naslednje:
\begin{items}
	\item preide v neko stanje
	\item zapiše nov simbol v celico, ki je pod oknom
	\item okno premakne eno celico levo ali desno
\end{items}

\subsect{Trenutni opis}
\Def{$TO = \Gamma^* \times Q \times \Gamma^*$ je množica vseh trenutnih opisov.\\
Nek trenutni opis $\langle \alpha_1, q, \alpha_2 \rangle$, ali krajše $\alpha_1\ q\ \alpha_2$ opisuje konfiguracijo Turingovega stroja.
\br
\begin{center}
\begin{tikzturing}
	\node      [cell, minimum width=3.6cm] {$\alpha_1$};
	\node (Ai) [cell, selected]            {};
	\node      [cell, minimum width=3cm]   {$\alpha_2$\ \ \ };
	\node      [cell]                      {\color{gray}$B$};
	\node      [cell]                      {\color{gray}$B$};
	\node      [cell]                      {\ ...\ \ };
	\node      [cell, end]                 {};

	%?must be a better way, zadnja črta niti ni naravnost
	\node (ne) at (40bp, 60bp) [head]  {$q$};
	\draw (ne.south) -- (40bp, 25bp) -- (60.5bp, 25bp) [->] to (Ai.north);
	%\node [below, minimum width=4cm] at (alpha1.south) {$\alpha_1$};
	%\node [below, minimum width=4cm] at (alpha2.south) {$\alpha_2$\ \ \ \ };
\end{tikzturing}
\end{center}
\br
Čitalno okno je nad prvim znakom niza $\alpha_2$, iz tega lahko razberemo:
\begin{items}
	\item če je $\alpha_1 = \varepsilon$, je okno skrajno levo
	\item če je $\alpha_2 = \varepsilon$, je okno nad $B$ in so naprej sami $B$-ji
\end{items}}

\subsect{Relacija $\vdash$}
\Def{Če sta $u,v$ trenutna opisa iz množice $TO$, ter $v$ neposredno sledi iz $u$ v enem koraku Turingovega stroja, tedaj pišemo $u \vdash v$.
\br
Naj bo $x_1 \dots x_{i-1}\ q\ x_i \dots x_n$ trenutni opis:
\begin{items}
\item če je $\delta(q,x_i) = \langle p,Y,D \rangle$:\\
$x_1 \dots x_{i-1}\ q\ x_i \dots x_n \vdash x_1 \dots x_{i-1}\ Y\ p\ x_{i+1} \dots x_n$
\item če je $\delta(q,x_i) = \langle p,Y,L \rangle$: 
	\begin{items}
	\item če je okno na robu ($i=1$), se Turingov stroj ustavi, ker je trak na levi omejen.
	\item če okno ni na robu ($i>1$), potem: $x_1 \dots x_{i-2} x_{i-1}\ q\ x_i \dots x_n \vdash x_1 \dots\ x_{i-2} p\ x_{i-1}\ Y\ x_{i+1} \dots x_n$
	\end{items}
\end{items}}
Imamo pa tudi posplošeno relacijo $u \vdash^* v$, ki pove, da trenutni opis $v$ sledi iz $u$ v enem ali večih korakih.
\Def{$u \vdash^* v$, če obstaja tako zaporedje $x_i, (i \in [0, 1, \dots, k], k \geq 0)$, da velja $u=x_0, v=x_k$ in $x_0 \vdash x_1 \wedge x_1 \vdash x_2 \wedge \dots \wedge x_{k-1} \vdash x_k$
\br
Torej, trenutni opis $v$ sledi iz $u$, v $k$ korakih Turingovega stroja.}
\sect{Jezik Turingovega stroja}
\Def{Jezik Turingovega stroja je:
\begin{equation*}
L(M) = \{ w\ |\ w \in \Sigma^* \wedge \varepsilon\ q_0\ w \vdash^*\alpha_1\ q_F\ \alpha_2 \wedge \alpha_1,\alpha_2 \in \Gamma^*, q_F \in F \}
\end{equation*}
}
Z besedami to pomeni, da je jezik Turingovega stroja množica besed, ki če jih damo na vhod stroja, povzročijo, da se ta v končno mnogo korakih znajde v končnem stanju.
\ \\
\begin{center}
\begin{tikzturing}
	\node (Ai) [cell, selected]          {};
	\node      [cell, minimum width=4cm] {$w$\ \ \ \ \ };
	\node      [cell]                    {\color{gray}$B$};
	\node      [cell]                    {\color{gray}$B$};
	\node      [cell]                    {\ ...\ \ };
	\node      [cell, end]               {};

	%?must be a better way, zadnja črta niti ni naravnost
	\node (ne) at (90bp, 60bp) [head] {$q_0$};
	\draw (ne.south) -- (90bp, 25bp) -- (0bp, 25bp) [->] to (Ai.north);
\end{tikzturing}
\br
Začetna konfiguracija Turingovega stroja.
\end{center}
\Def{Jezik $L$ je Turingov jezik, če obstaja Turingov stroj $M$, tak, da je $L = L(M)$.}
\subsect{Ugotavljanje pripadnosti besed Turingovemu jeziku}
Pri vprašanju ali je neka beseda v jeziku, Turingove jezike ločimo na:
\begin{items}
\item Odločljive - obstaja algoritem, s katerim se lahko za poljubno besedo odločimo, ali pripada jeziku.
\item Neodločljive - v splošnem ni algoritma, ki bi za poljubno vhodno besedo z DA ali NE odgovoril na vprašanje pripadnosti.
	\begin{items}
	\item če je odgovor DA, to ugotovimo v nekem končnem številu korakov.
	\item če je odgovor NE, pa ni nujno, da se bo stroj kdaj ustavil.
	\end{items}
\end{items}

%?\fixme - vennov diagram beseda w znotraj L kroga... pomojm ne rabmo :P

%?where does this go?
%Terminologija: re (recursively enumerable, Turing recognizable)%?semi-decidable? 
%Rekurzivni jezik (decidable)%?where does this go?

\fixme - vennov diagram odločljivi jeziki znotraj Turingovih?

\Primer{Zapiši Turingov stroj, ki sprejema jezik $L=\{0^n 1^n | n \geq 1\}$\\
	Skica izvajanja stroja:
	\begin{items}
	\item $0^{n}1^{n}$ - vhodna beseda
	\item $X0^{n-1}1^{n}$ - zamenjamo najbolj levo $0$ z $X$
	\item $X0^{n-1}Y1^{n-1}$ - premaknemo okno desno do najbolj leve $1$ in jo zamenjamo z $Y$
	\item $XX0^{n-2}Y1^{n-1}$\\ 
		$XX0^{n-2}YY1^{n-2}$ - ponovimo in vidimo, da bomo niz sprejeli, če je prave oblike.
	\end{items}
	Turingov stroj zapišemo kot $M=\langle Q,\Sigma,\Gamma,\delta,q_0,B,F \rangle$:
	\begin{items}
    \item $Q=\{ q_0,q_1,q_2,q_3,q_4 \}$
    \item $\Sigma = \{ 0,1 \}$
    \item $\Gamma = \{ 0,1,B,X,Y \}$
    \item $F = \{ q_4 \}$
    \item $\delta$ bomo definirali s tabelo
	\end{items}

    Pomen stanj:
    \begin{items}
    \item $q_0$ - začetno stanje in stanje pred zamenjavo 0 z X
    \item $q_1$ - premikanje desno do 1
    \item $q_2$ - zamenjava 1 z Y in premikanje levo do X
    \item $q_3$ - najde X in se premik desno
    \item $q_4$ - končno stanje
    \end{items}

    Tabela prehajanja stanj:\\
	\begin{center}
    \begin{tabular}{ c | c c c c c}
	& 0 & 1 & B & X & Y\\ \hline
	$x_0$& $\langle q_1,X,D\rangle$ & -- & -- & $\langle q_3,Y,D\rangle$ & --\\
	$x_1$& $\langle q_1,0,D\rangle$ & $\langle q_2,Y,L\rangle$ & -- & $\langle q_1,Y,D\rangle$ & --\\
	$x_2$& $\langle q_2,0,D\rangle$ & -- & $\langle q_0,X,D\rangle$ & $\langle q_2,Y,L\rangle$ & --\\
	$x_3$& -- & -- & -- & $\langle q_3,Y,D\rangle$ & $\langle q_4,B,D\rangle$\\
	$x_4$& -- & -- & -- & -- & --\\
	\end{tabular}
	\end{center}
	\br
	Izvajanje stroja s trenutnimi opisi:
	\[ q_0 0011 \vdash X q_1 011 \vdash X 0 q_1 11 \vdash X q_2 0 Y 1 \vdash \dots \]
}
%?zapiski 2007 imajo tu še nekaj o turingovih jezikih
\subsect{Turingov stroj kot računalnik funkcij}
Imamo Turingov stroj, ki ima na traku neko število ničel, ki predstavljajo pozitivna naravna števila, ločena z enicami:
%	\[ 0^{i_1} 1 0^{i_2} 1  \dots 1 0^{i_k} \]
%?skupine ničel so i_1, i_2, ..., kjer so i naravna števila (mjbi i+1 ničel)  
\ \\
\begin{center}
\begin{tikzturing}
	\node (Ai) [cell, selected]            {};
	\node      [cell, minimum width=2cm]   {$0^{i_1}$\ \ \ };
	\node      [cell]                      {$1$};
	\node      [cell, minimum width=1.4cm] {$0^{i_2}$};
	\node      [cell]                      {$1$};
	\node      [cell]                      {\ ...\ \ };
	\node      [cell]                      {$1$};
	\node      [cell, minimum width=2.6cm] {$0^{i_k}$\ \ \ \ };
	\node      [cell]                      {\color{gray}$B$};
	\node      [cell]                      {\color{gray}$B$};
	\node      [cell]                      {\ ...\ \ };
	\node      [cell, end]                 {};

	%?must be a better way, zadnja črta niti ni naravnost
	\node (ne) at (70bp, 60bp) [draw, minimum width=2cm, minimum height=1.2cm]  {$q_0$};
	\draw (ne.south) -- (70bp, 25bp) -- (0bp, 25bp) [->] to (Ai.north);
\end{tikzturing}
\end{center}
Recimo, da se stroj po nekem številu korakov ustavi in ima na traku skupino ničel $0^m$, na levi in desni strani skupine pa same $B$-je. S tem je stroj morda izračunal neko funkcijo:
	\[ f^{(k)}:\mathbb{N}_+^k \rightarrow \mathbb{N}_+ \mbox{\ \ oz. \ \ } f(i_1, i_2, \dots, i_k) = m \]
%?\fixme - slika TS s skupino ničel na traku\br... pomojm ne rabmo :P
Funkcija $f$ ni nujno definirana za vsako $k$-terico iz $\mathbb{N}_+^k$, torej je parcialna funkcija, kadar pa je definirana povsod, pravimo da je totalna. Stroj se pri nedefiniranih $k$-tericah pač na neki točki ustavi in pri tem na traku ne pusti le ene skupine ničel, ali pa se sploh ne ustavi.
Isti turingov stroj hkrati računa več funkcij: $f^{(1)}, f^{(2)}, \dots f^{(k)}$.%?računa ali "lahko računa".. ne štekam ubistvu čist

\subsubsection{Parcialna rekurzivna funkcija}
\Def{Vsaka funkcija $f^{(k)}:\mathbb{N}_+^k \rightarrow \mathbb{N}$, ki jo lahko izračuna nek Turingov stroj, je parcialna rekurzivna funkcija. Če je $f^{(k)}$ definirana za vse $k$-terice, jo imenujemo totalna rekurzivna funkcija (včasih samo rekurzivna funkcija)}
Vse običajne aritmetične funkcije so parcialne ali celo totalne rekurzivne funkcije. V primerih si bomo pogledali nekaj primerov, tu pa jih nekaj naštejmo: $m+n,\ m*n,\ n!,\ 2^n,\ \lceil \log(n) \rceil,\ m^n,\ \dots$.
%so najdl primer, ki ne spada sem z diagonalizacijo
%na začetku so gledali totalne... pa so vidl da morajo parcialne
\begin{primeri}
\item
    Ali je $f(m,n)=m+n$ (parcialno) rekurzivna?\\
    Skica stroja, ki računa $m+n$:
    \begin{items}
    \item $0^m 1 0^m$ - vhodna beseda
    \item $B0^{m-1} 1 0^m$ - izbriši prvo ničlo
    \item $B0^{m+n}$ - premakni se do 1 in jo zamenjaj z 0
    \end{items}%?DN naredi cel stroj
\item
    Ali je $f(m,n)=m*n$ (parcialno) rekurzivna?\\
    Skica stroja, ki računa $m*n$:
    \begin{items}
    \item $0^m 1 0^n$ - vhodna beseda
    \item $0^m 1 0^n 1$ - premakni se na konec in zapiši 1 (ločnica za rezultat)
    \item $B 0^{m-1} 1 0^n 1$ - premakni se na začetek in izbriši 0
    \item $B 0^{m-1} 1 0^m 1 0^n$ - prekopiraj $n$ ničel za ločnico (in ničle)
    \item $B^{m} 1 0^m 1 0^{m*n}$ - ponavljaj tadva koraka, dokler ni več ničel pred prvo 1
    \item $B^{m+n+2}0^{m*n}$ - izbriši del, ki ne spada v rezultat 
    \end{items}%?naredi cel stroj
\end{primeri}

\sect{Razširitve Turingovega stroja}
V tem odseku bomo spoznali nekaj razširitev Turingovega stroja in pokazali da so enako močne kot osnovni model. Poleg tega bomo naredili še pregled alternativnih modelov, za katere se je tudi izkazalo, da so enako močni.%, nato pa si bomo ogledali še nekaj stvari, ki jih Turingov stroj kljub vsemu ne more izračunati.

\Odmakni{Postopek dokazovanja}{Recimo, da je $\mathcal{M}$ razred modelov, za katerega želimo dokazati, da je ekvivalenten razredu Turingovih strojev. Poiskati moramo sistematičen, končen postopek S, ki poljubnemu stroju $M \in \mathcal{M}$ priredi nek Turingov stroj $M'$, ki je sposoben simulirati $M$.
\begin{center}
\begin{tikzpicture}[vert/.style={circle, draw,fill=black, inner sep=1pt}]
	\node (l) [vert] at (0.1cm, 0.2cm) {};
	\node [below=2pt] at (l.south) {$M$};
	\node (r) [vert] at (4.6cm, 0.8cm) {};
	\node [below=2pt] at (r.south){$M'$};

	\draw (0cm,0cm) ellipse (1.3cm and 1.1cm) node(le) {};
	\node at (le) [below=1.2cm] {$\mathcal{M}$};
	\draw (4.5cm,0.2cm) ellipse (1.4cm and 1.0cm) node(re) {};
	\node at (re) [below=1.1cm] {TS};

	\draw [bend left, ->] (l) to node[auto] {S} (r);
\end{tikzpicture}
\end{center}}
\subsect{Nadzorna enota kot pomnilnik}
Vsako stanje stroja, je sestavljeno iz dveh delov -- stanja avtomata, ter shrambe za tračne znake. Novo množico stanj zapišemo kot $Q=K\times\Gamma$, kjer je $K$ stara množica stanj in $\Gamma$ tračna abeceda.
\Primer{Sestavi Turingov stroj za razpoznavanje besed, pri katerih se prvi znak ne ponovi:\\
	Stroj $M=\langle Q,\Sigma,\Gamma,\delta,q_0,B,F \rangle$ zapišemo kot:
	\begin{items}
	\item $M=\langle Q, \{0,1\}, \{0,1,B\}, \delta, \langle q_0, B \rangle, B, F \rangle$
	\item $Q=\{ q_0, q_1 \} \times \{0,1,B\} = \{ \langle q_0, 0\rangle , \langle q_0, 1\rangle , \langle q_0, B\rangle , \langle q_1, 0\rangle , \langle q_1, 1\rangle , \langle q_1, B\rangle\} $
	\item $F=\{ \langle q_1, B \rangle \}$
	\item $\delta$ zapišemo kot:
		\begin{items}
		\item Shrani prvi znak besede v stanje stroja:\\
			$\delta(\langle q_0, B\rangle, 0) = \langle\langle q_1, 0 \rangle, 0, D\rangle$\\
			$\delta(\langle q_0, B\rangle, 1) = \langle\langle q_1, 1 \rangle, 1, D\rangle$
		\item Premakni okno v desno do prvega znaka, enakega shranjenemu:\\
			$\delta(\langle q_1, 0\rangle, 1) = \langle\langle q_1, 0 \rangle, 1, D\rangle$\\
			$\delta(\langle q_1, 1\rangle, 0) = \langle\langle q_1, 1 \rangle, 0, D\rangle$
		\item Če prebereš $B$, pojdi v končno stanje:\\
			$\delta(\langle q_1, 0\rangle, B) = \langle\langle q_1, B \rangle, karkoli \rangle$\\
			$\delta(\langle q_1, 1\rangle, B) = \langle\langle q_1, B \rangle, karkoli \rangle$
		\item Sicer se ustavi. To dosežemo tako, da ne definiramo prehodov:\\
			$\delta(\langle q_1, 0\rangle, 0)$ in $\delta(\langle q_1, 1\rangle, 1)$
		\end{items}
	\end{items}
}
\subsect{Večsledni trak}
Na traku imamo več kot eno sled, kar pomeni, da s traku beremo $k$-terice tračnih znakov, kar zapišemo kot: $\Gamma=\Gamma_1\times\Gamma_2\times\dots\times\Gamma_k$.
\ \\
\begin{center}
\begin{tikzturing}
	\node (Ai) [cell1, selected] {$A1_{0}$};
	\node at (0bp,-0.6cm) [cell2, selected] {$A2_{0}$};
	\node at (0bp,-1.2cm) [cell3, selected] {$A3_{0}$};

	\foreach \x in {1,2,3} {
		\node [cell1] {$A1_{\x}$};
		\node [cell2] {$A2_{\x}$};
		\node [cell3] {$A3_{\x}$};
	}

	\node [cell1] {\ ...\ \ };
	\node [cell2]  {\ ...\ \ };
	\node [cell3]  {\ ...\ \ };

	\node [cell1, end] {};
	\node [cell2, end] {};
	\node [cell3, end] {};

	%?must be a better way, zadnja črta niti ni naravnost
	\node (ne) at (40bp, 60bp) [draw, minimum width=2cm, minimum height=1.2cm]  {$q_0$};
	\draw (ne.south) -- (40bp, 25bp) -- (0bp, 25bp) [->] to (Ai.north);
\end{tikzturing}
\end{center}

\Primer{Sestavi Turingov stroj, ki preveri, ali je vhodno število praštevilo.\\
	Skica stroja:
	\begin{items}
	\item Trak ima tri sledi:
		\begin{items}
		\item na prvi sledi je vhodno število
		\item na drugi sledi je števec, ki na začetku hrani število 2
		\item tretjo sled uporabimo za delovno sled, na začetku je lahko prazna.
		\end{items}
	\item Stroj deluje tako:
		\begin{items}
		\item prepiši število s prve sledi na tretjo sled
		\item odštevaj število iz druge sledi od števila na tretji sledi
		\item če se odštevanje konča z 0, se ustavi (ni praštevilo)
		\item sicer število na drugi sledi povečaj za 1
		\item če je število na drugi sledi enako tistemu na prvi, sprejmemo (je praštevilo)
		\item sicer, ponovimo postopek
		\end{items}
	\end{items}
}
\subsect{Prestavljanje vsebine traku}
Recimo, da bi s traku radi vzeli nekaj zaporednih znakov tako, kot da bi jih izrezali iz traku in nato trak zlepili nazaj skupaj, izrezane simbole pa bi si pri tem seveda radi nekako zapomnili. Tudi to metodo realiziramo s pomočjo shrambe za tračne simbole v nadzorni enoti, a moramo pri tem paziti, da je funkcija prehodov pravilno napisana.
\br\fixme slika "gube" na traku in slika nadzorne enote
\Primer{Sestavi Turingov stroj, ki premakne vsebino traku za 2 celici v desno.\\
	Skica stroja:
	\begin{items}
    \item $Q$ vsebuje stanja oblike: $\langle q, A_1, A_2 \rangle;\ q \in \{ q_1, q_2 \},\ A_1, A_2 \in \Gamma$
    \item $\Gamma$ poleg ostalih znakov, vsebuje še poseben znak $X$, ki označuje izpraznjeno celico na traku
	\item $F=\{ q_2 \}$
	\item $\delta$ zapišemo kot:
		\begin{items}
		\item Prva koraka -- zapomni si in izprazni prvi in drugi znak:\\
			$\delta(\langle q_1, B, B\rangle, A_1) = \langle\langle q_1, B, A_1 \rangle, X, D \rangle $\\
			$\delta(\langle q_1, B, A_1\rangle, A_2) = \langle\langle q_1, A_1, A_2 \rangle, X, D \rangle $
		\item Zapomni si nov znak in prvega iz shrambe zapiši na trak:\\
			$\delta(\langle q_1, A_i, A_{i+1}\rangle, A_{i+2}) = \langle\langle q_1, A_{i+1}, A_{i+2} \rangle, A_i, D \rangle $
		\item Zadnja koraka -- zapiši vsebino shrambe na trak:\\
			$\delta(\langle q_1, A_{n-1}, A_{n}\rangle, B) = \langle\langle q_1, A_{n}, B \rangle, A_{n-1}, D \rangle $\\
			$\delta(\langle q_1, A_{n}, B\rangle, B) = \langle\langle q_2, B, B \rangle, A_{n}, L \rangle $
		\end{items}
	\end{items}
}

%?\fixme ... tu je razlagal tisto neizračunljivo funkcijo nad matrikami. btw, @zidar: poglej tor2-dodatno.pdf - tam govori o preroku

\subsect{Podprogrami}
\fixme
%?Imamo neka posebna stanja, ki signalizirajo vhod in izhod iz podprograma%?je tu govoril o dveh strojih?

\subsect{Turingov stroj z dvosmernim trakom}
Imamo Turingov stroj, ki ima trak neomejen v obe smeri. Vhodna beseda je na začetku napisana nekje na traku, okno pa je na prvem znaku besede.

%kako zbrišem črto pri prvem ...?
\begin{center}
\begin{tikzturing}
	\node      [cell]                    {\ ...\ \ };
	\node      [cell]                    {\color{gray}$B$};
	\node      [cell]                    {\color{gray}$B$};
	\node (Ai) [cell, selected]          {};
	\node      [cell, minimum width=4cm] {$w$\ \ \ \ \ };
	\node      [cell]                    {\color{gray}$B$};
	\node      [cell]                    {\color{gray}$B$};
	\node      [cell]                    {\ ...\ \ };
	\node      [cell, end]               {};

	%?must be a better way, zadnja črta niti ni naravnost
	\node (ne) at (95bp, 60bp) [draw, minimum width=2cm, minimum height=1.2cm]  {$q_0$};
	\draw (ne.south) -- (95bp, 25bp) -- (53.5bp, 25bp) [->] to (Ai.north);
\end{tikzturing}
\end{center}
\ \\
Stroj je definiran skoraj enako kot osnovni Turingov stroj, le funkcija prehodov $\delta$ je enostavnejša, saj ni treba skrbeti, kaj se zgodi, če zadanemo levi rob, kot pri običajnem Turingovemu stroju.
\br
\Trditev{Turingov stroj z dvosmernim trakom ni šibkejši od osnovnega Turingovega stroja.}
\Dokaz{Stroj se lahko vede kot da je omejen na levi. Na začetku izvajanja se premaknemo levo, zapišemo poseben znak, ki nam pomeni konec traku. Nato se premaknemo desno in stroj normalno izvajamo.}%to smo delali tudi na vajah - check it
\ \\
\Trditev{Turingov stroj z dvosmernim trakom ni močnejši od osnovnega.}
\Dokaz{Imamo Turingov stroj $M$ z dvosmernim trakom:
\ \\
%kako zbrišem črto pri prvem ...?
\begin{center}
\begin{tikzturing}
	\node [cell] {\ ...\ \ };

	\foreach \x in {-3,-2,-1} { \node [cell] {$A_{\x}$}; }
	\node (Ai) [cell, selected] {$A_{0}$};
	\foreach \x in {1,2,3} { \node [cell] {$A_{\x}$}; }

	\node [cell] {\ ...\ \ };
	\node [cell, end]      {};

	%?must be a better way, zadnja črta niti ni naravnost
	\node (ne) at (70bp, 60bp) [draw, minimum width=2cm, minimum height=1.2cm]  {$q_0$};
	\draw (ne.south) -- (70bp, 25bp) -- (95bp, 25bp) [->] to (Ai.north);
\end{tikzturing}
\end{center}
\ \\
Stroju $M$ priredimo dvosledni Turingov stroj $M'$. Zgornja sled nam bo predstavljala celice od $A_0$ naprej, spodnja pa vse tiste, levo od $A_0$:
\ \\
\begin{center}
\begin{tikzturing}
	\node (Ai) [cell1, selected] {$A_{0}$};
	\node at (0bp,-0.6cm) [cell2, selected] {\#};

	\foreach \x in {1,2,3} {
		\node [cell1] {$A_{\x}$};
		\node [cell2] {$A_{-\x}$};
	}

	\node [cell1] {\ ...\ \ };
	\node [cell2]  {\ ...\ \ };

	\node [cell1, end] {};
	\node [cell2, end] {};

	%?must be a better way, zadnja črta niti ni naravnost
	\node (ne) at (40bp, 60bp) [draw, minimum width=2cm, minimum height=1.2cm]  {$q_0$};
	\draw (ne.south) -- (40bp, 25bp) -- (0bp, 25bp) [->] to (Ai.north);
\end{tikzturing}
\end{center}

Stroj $M'$ deluje tako:
\begin{items}
\item naeenkrat dela le z eno sledjo
\item ko na drugi sledi vidi \#, zamenja aktivno sled
\item na zgornji sledi dela enako kot $M$
\item na spodnji se obrne smer premikanja
\end{items}
%(tu smo pomojem napisali še 2x isto)

%Formalizacija... ne bomo delal

%Sklep.. sta ekvivalentna - kar izračuna dvosmerni, lahko tudi osnovni.
%Izrek: Za jezik L obstaja TS z dvosmernim trakom, n.t.k., za L obstaja osnovni TS.

%nekdo je vprašal, če je bijekcija, pa je rekel, da ne čist?
}

\subsect{Večtračni Turingov stroj}
Večtračni Turingov stroj ima $k>1$ trakov, ki so neomejeni v obe strani. Poleg tega ima vsak trak svoje okno, ki se lahko neodvisno od ostalih premika ob vsakem koraku. Spet imamo na začetku vhodno besedo na prvem traku in je okno prvega traku na prvem znaku vhodne besede, na ostali trakovi pa so prazni.

\begin{center}
\begin{tikzturing}[cell11/.style={cell1,fill=white}, cell22/.style={cell2,fill=white}]
	\node [cell11] {\ ...\ \ };
	\node at (0bp,-1.5cm) [cell22]  {\ ...\ \ };
	\node at (0bp,-3.0cm) [cell3]  {\ ...\ \ };

	\node (Ai) [cell11, selected] {$w_{0}$};
	\node (Ai2) [cell22, selected] {\color{gray}$B$};
	\node (Ai3) [cell3, selected] {\color{gray}$B$};

	%?must be a better way, zadnja črta niti ni naravnost
	\node (ne) at (67bp, 60bp) [draw, minimum width=2cm, minimum height=1.2cm]  {$q_0$};
	\draw (ne.south) -- (67bp, 25bp) -- (29bp, 25bp) [->] to (Ai.north);
	\draw (ne.south) -- (67bp, -20bp) -- (29bp, -20bp) [->] to (Ai2.north);
	\draw (ne.south) -- (67bp, -65bp) -- (29bp, -65bp) [->] to (Ai3.north);

	\foreach \x in {1,2,3} {
		\node [cell11] {$w_{\x}$};
		\node [cell22] {\color{gray}$B$};
		\node [cell3] {\color{gray}$B$};
	}

	\node [cell11] {\ ...\ \ };
	\node [cell22]  {\ ...\ \ };
	\node [cell3]  {\ ...\ \ };

	\node [cell11, end] {};
	\node [cell22, end] {};
	\node [cell3, end] {};
\end{tikzturing}
\end{center}

\Def{Korak stroja $\delta$ opišemo kot:
	\[\delta = Q \times \Gamma^k \rightarrow Q\times(\Gamma\times\{ L,D,- \})^k \]
	Torej, na vsakem koraku dobimo iz trenutnega stanje, ter tračnega simbola vsakega traku, neko novo stanje, ter za vsak trak neodvisno nov simbol in premik.}

\Trditev{Večtračni Turingov stroj je enako močen kot osnovni model.}
\Dokaz{
	\Odmakni{($\Rightarrow$)}{Večtračni Turingov stroj uporabi le prvi trak.}
	\Odmakni{($\Leftarrow$)}{Turingovemu stroju $M$ s $k$-trakovi priredimo $2k$-sledni v obe strani neskončni Turingov stroj $M'$.
	Za vsak trak stroja $M$ imamo tako dve sledi v $M'$ -- na zgornji sledi je zapisana oznaka $X$, ki pove, kje naj bi bilo okno na tem traku stroja $M$, na spodnji sledi pa je zapisana vsebina tega traku stroja $M$.

\begin{center}
\begin{minipage}[t]{6cm}
\begin{tikzturing}[cell11/.style={cell1,fill=white}]
	\node [cell11] {\ ...\ \ };
	\node at (0bp,-1.5cm) [cell2]  {\ ...\ \ };

	\node (Ai) [cell11, selected] {$a$};

	\node       [cell2] {$c$};
	\node (Ai2) [cell2, selected] {$d$};

	%?must be a better way, zadnja črta niti ni naravnost
	\node (ne) at (50bp, 60bp) [draw, minimum width=2cm, minimum height=1.2cm]  {$q$};
	\draw (ne.south) -- (50bp, 25bp) -- (29bp, 25bp) [->] to (Ai.north);
	\draw (ne.south) -- (50bp, 25bp) -- (57bp, 25bp) [->] to (Ai2.north);

	\node [cell11] {$b$};

	\node [cell11] {\color{gray}$B$};
	\node [cell2]  {\color{gray}$B$};

	\node [cell11] {\ ...\ \ };
	\node [cell2]  {\ ...\ \ };

	\node [cell11, end] {};
	\node [cell2, end] {};
\end{tikzturing}
$k$-tračni stroj $M$
\end{minipage}
\begin{minipage}[t]{6cm}
\begin{tikzturing}
	\node [cell1] {\ ...\ \ };
	\node at (0bp,-0.6cm) [cell2]  {\ ...\ \ };
	\node at (0bp,-1.2cm) [cell3]  {\ ...\ \ };
	\node at (0bp,-1.8cm) [cell4]  {\ ...\ \ };

	\node [cell1] {$X$}; \node [cell1] {\color{gray}$B$};
	\node [cell2] {$a$}; \node [cell2] {$b$};
	\node [cell3] {\color{gray}$B$}; \node [cell3] {$X$};
	\node [cell4] {$c$}; \node [cell4] {$d$};

	\node (Ai) [cell1,selected] {\color{gray}$B$};
	\node      [cell2,selected] {\color{gray}$B$};
	\node      [cell3,selected] {\color{gray}$B$};
	\node      [cell4,selected] {\color{gray}$B$};

	\node [cell1] {\ ...\ \ };
	\node [cell2] {\ ...\ \ };
	\node [cell3] {\ ...\ \ };
	\node [cell4] {\ ...\ \ };

	\node [cell1, end] {};
	\node [cell2, end] {};
	\node [cell3, end] {};
	\node [cell4, end] {};

	%?must be a better way, zadnja črta niti ni naravnost
	\node (ne) at (60bp, 60bp) [draw, minimum width=2cm, minimum height=1.2cm]  {$q$};
	\draw (ne.south) -- (60bp, 25bp) -- (85.5bp, 25bp) [->] to (Ai.north);

\end{tikzturing}
$2k$-sledni stroj $M'$
\end{minipage}
\end{center}
\br

Stroj $M'$ torej hrani trenutni položaj na trakovih s dodatno sledjo, ki ima v ustrezni celici zapisan simbol $X$.
\br
Poleg tega pa pri $M'$ potrebujemo še drugačno nadzorno enoto, ki hrani:
\begin{items}
\item Stanje stroja
\item $k$ tračnih simbolov
\item Števec na intervalu $[0,k]$, ki nam pove, koliko simbolov $X$ je še desno od trenutnega položaja okna.
\end{items}
\ \\
Stroj $M'$ simulira en korak stroja $M$ tako da:
\begin{items}
\item Okno pomika v desno
\item Ko na neki sledi naleti na simbol $X$:
	\begin{items}
	\item V nadzorno enoto shrani simbol iz naslednje sledi
	\item Zmanjša števec za 1.
	\end{items}
\item Ko števec doseže 0, se začne pomikati v levo
\item Ko naleti na simbol $X$
	\begin{items}
	\item Zamenja tračni simbol na naslednji sledi, enako kot bi naredil stroj $M$
	\item Premakne se levo ali desno, enako kot bi naredil stroj $M$
	\item Poveča števec za 1
	\end{items}
\item Ko števec doseže $k$, nadzorna enota preide v novo stanje, enako kot bi stroj $M$
\end{items}
\ \\
En korak stroja $M$ torej simuliramo s končno dolgim sprehodom v desno in levo.
}}%konec dokaza


\subsect{Nedeterministični Turingov stroj}
Pri nedeterminističnemu Turingovemu stroju, imamo lahko v določeni konfiguraciji več možnosti, kako bo stroj nadaljeval z delom. Za formalni zapis tega je potrebno spremeniti le funkcijo prehodov $\delta$, ki sedaj slika v množico konfiguracij, namesto v eno samo:\\
 \[ \delta:Q\times\Gamma \rightarrow 2^{Q\times\Gamma\times\{ L,D,- \}} \]

\Def{Nedeterministični Turingov stroj sprejme besedo natanko tedaj, kadar obstaja končno zaporedje korakov, po katerem pridemo do končnega stanja.}

\Primer{%nekoliko lame primer... where's the action :)
$\delta(0, a) = \{ \langle q_1, b, L \rangle, \langle q_2, c, D \rangle, \langle q_3, a, L \rangle, \langle q_2, B, L \rangle \}$\\
Stroj bo izbral tisto preslikavo, ki ga vodi k sprejetju vhodne besede. Če to ni mogoče, se bo stroj ali ustavil v nekončnem stanju, ali pa se sploh ne bo ustavil.
}

\Trditev{Nedeterministični Turingov stroj zmore vse kar zmore osnovni Turingov stroj.}
\Dokaz{Funkcija prehodov $\delta$ osnovnega TS je le poseben primer funkcije $\delta$ nedeterminističnega Turingovega stroja.}
\Trditev{Nedeterministični Turingov stroj ni močnejši od osnovnega modela.}

\Dokaz{Simulacija nedeterminističnega Turingovega stroja z osnovnim:\\
%slika 
%
% d     a
%   |-------
% q |   o
%
%
\fixme slika\\
Naj bo $M$ nek nedeterministični Turingov storj in naj ima njegov program v vsaki mmnožici $\delta(q,a)$ največ $r$ možnih potez, kjer je $r$ končno število.\\
Stroju $M$ priredimo osnovni 3-sledni Turingov stroj $M'$, z naslednjimi lastnostmi:
\begin{items}
\item na prvi sledi ima abecedo stroja $M$
\item na drugi sledi generira zaporedje navodil besed nad abecedo $\{1, 2, \dots, r\}$ v leksikografskem vrstnem redu (npr. $r = 3: 1,2,3,11,12,13,\dots)$
\item na tretji sledi simulira stroj $M$, kot da bi ta izbral poteze skladno s tekočimi navodili
\end{items}
Natančneje stroj $M'$ deluje tako:
\begin{items}
\item na drugi sledi sestavi novo, naslednje navodilo
\item prepiše vhodno besedo s prve na tretjo sled
\item na tretji sledi simulira stroj $M$, kot da bi ta izbral svoje poteze skladno s tekočimi navodili.\\
      Pri tem:
      \begin{items}
      \item če $M'$ pride do konca navodila in je tedaj v končnem stanju, vhodno besedo sprejme in konča, kot bi to storil tudi $M$
      \item sicer nadaljuje s prvim korakom ali pa se ustavi v končnem stanju
      \end{items}
\end{items}
}
\Trditev{Če $M$ sprejme besedo jo sprejme tudi $M'$.}
\Izrek{Za jezik $L$ obstaja nedeterministični Turingov stroj natanko tedaj, ko za $L$ obstaja osnovni Turingov stroj.}
\Neurejeno
%naj ima njegov program delta v vsaki množici delta q a kvečjemu r možnih potez(oz. elementov delta? množice)
%Stroju M priredimo trisledni osnovni TS M'
%na prvi sledi ima M' vhodno besedo M
%na drugi sledi M' generira/izpisuje navodila eno za drugim. navodila so besed nad {1,2...r} v leksikografskem redu.
%npr r=3 ... 1,2,3, 11, 12, 13, 21, 22, 23, 31, 32, 33, 111, 112, 
%na tretji sledi simulira stroj M, kot da bi M sam izbral svoje poteze, skladno s tekočim navodilom.% ajprov?

%Natančneje:
%M' na 2. sledi sestavi novo, naslednje navodilo
%prepiše vhodno besedo s prvega na tretji sled (prej lahko tretha sked zbrupe(tretjo sled zbriše), če je kaj ostalo od prej)
%na tretji sledi oponaa stroj M, kot da bi ta izbiral svoje poteze po tekočem navodilu.

%pri tem: 
%če M' pride do konca navodila, in je tedaj v končnem stanju, besedo sprejmemo.
%sicer če ne pride do konca navodila, ali pa se ustavi v nekončnem stanju, potem pojdi v (natančneje prva vrstica)
%a to je tko k depth first? recimo no
%kaj če se navodilo zacikla? to se da rešit... i dunno :)
%aha, ne more se - ... ker ima končno mnogo nečesa
%hm a se lahko nts konča, simulator pa zacikla? nas ne briga.
%
%Trditev: če M sprejme besedo, jo sprejme tudi M' 
%Dokaz: 
%izrek: za L obstaja nts, ntk za L obstaja osnovni ts.

\subsect{Večdimenzionalni Turingov stroj}
... k>=2
premikamo se lahko v 2k smeri
...
...
...
\Primer{k=3\\
\fixme - 3D trak s trollhands puščico na celico
}

\subsubsect{Turingov stroj z več okni}
\fixme - slika z večimi okni

%-----------------------predavanja 4-------------------------------
%Turing se je zgledoval po človeku

%drugi po funkcijah
%kaj je računanje, izračunljivost, algoritem... na številsko-teoretskih funkcijah f:N->N ... totalne/parcialne
%študirali so totalne f:N->N
%Cilji: storga mat. definicija pojmov s tem da zadosti 2 stvarem:
	%zajeti mora vse "izračunljve funkcije" (vse kar si lahko zamislimo kot problem za računanje)
	%za vsako tako f, mora biti razviden mehaničen postopek za izračun njenih vrednosti
%(HK,HG,lambda)

%zgledovanje po (naravnem) jeziku
%Postov stroj, Algoritmi Markova
%računanje oz. reševanje mat. problemov je pri človeku preoblikovanje množice besed v drugo (opis problema, v opis rešitve)
\sect{Alternative Turingovemu stroju}
\subsect{Rekurzivne funkcije}
%(GK) Gödel, Kleene
Definiral je funkcije: ničelna, naslednik, projekcija.
Dodal je pravili sestavljanja, kako iz začetnih in že sestavljenih dobimo novo: kompozicija, primitivna rekurzija. %grafek vseh sestavljivih (primitivno rekurzivnih) funkcij \_/
%godel je probal par funkcij in mu je ratal... kar je blo lepo... še lepš pa:
Konstrukcija take funkcije opisuje tudi mehanični postopek za izračun vrednosti funkcije, to pa je tudi kandidat za formalni opis pojma algoritma.
\br
Ampak... Ackermannova funkcija ni primitivno rekurzivna in narašča hitreje od vsake funkije, ki pripada primitivno rekuzivnim.
%\[ A(m,n) { n+1, m=0 
%          { A(m-1,1), m>0 in n=0
%          { A(m-1,1, A(m, n-1)), m>0 in n>0\]%obstaja šeena def

Kleene leta 1936 doda šeeno pravilo sestavljanja, $\mu$-operacija. %to zato, da naredi totalno, čeprov je možno parcialne
\Def{Totalne š.t. funkcije $f:N^k\leftarrow N$, ki se dajo konstruirati iz treh začetnih funkcij s končno mnogo uporabami treh pravil sestavljanja se imenujejo rekurzivne funkcije.}

Razred rekurzivnih funkcij
...
\begin{items}
\item $\zeta(n)=0 \forall n$ - ničelna
\item $\sigma(n)=n+1 \forall n$ - naslednik
\item $\pi(n_1, n_2, \dots, n_k)=n_i \forall n..$ - projekcija
\end{items}
Pravila sestavljanja
1. Če so dane funkcije $g:N^m \leftarrow N$ in $n_h:N^k \leftarrow N$, kjer i 1-m, potem je funkcija $f(n_1,n_2,\dots,n_k) \mbox{ po def } g(h_{1}(n_1,n_2,\dots,n_k),\dots,h_m(n_1,n_2,\dots,n_k))$ sestavljena s kompozicijo funkcij
2. Če sta dani funkciji $g:N^k \leftarrow N$ in $h:N^{k+1}  \leftarrow n$, potem je $f$ definiriana z:
	\[f(n_1, n_2, \dots, n_k, 0) \mbox{ po def } g(n_1, n_2, \dots, n_k)\]
	\[f(n_1, n_2, \dots, n_k, m+1) \mbox{ po def } h(n_1, n_2, \dots, n_k, m), f(n_1, n_2, \dots, n_k, m)), za m \geq 0\]
sestavljeno s .... in $g$ in $h$
3. Če je funkcija $g:N^{k+1} \leftarrow N$ taka, da za vsako $k$-terico naravnih števil $n_1, n_2, \dots, n_k$ obstaja n ..neki.. m, da je $g(n_1, n_2, \dots, n_k, m) = 0$, potem je funkcija:
\[ f(n_1, n_2, \dots, n_k) po def \mu x g(n_1, \dots, n_k, x)\]
sestavljena z $\mu$-operacijo iz funkcije $g$.
%Pri tem je $\mu$-operacija definirana z:
%\[ \mu x g(n_1, \dots, n_k, x) po def je najmanjši X, pri katerem je g (n_1, \dots n_k, X) = 0\]

%---
Konstrukcija rekurzivne funkcije $f$ je končno zaporedje $f_1,f_2,\dots,f_L$, kjer je $f_L=f$ in je vsaka funkcija $f_i$ vmes, bodisi začetna, bodisi sestavljena z enim izmed treh pravil iz predhodnic v tem zaporedju %glej grafek

%zaeenkrat nismo našli Ackermann2, ki bi to pokvarila :)
\Povzetek{Algoritem po Gödel-Kleenu(GK) je ravno konstrkucija rekurzivne funkcije.\\
	Računanje po GK je izračun vrednosti funkcije tako, kot jo narekuje njena konstrukcija.\\
	Funkcija je izračunljiva po GK, če je rekurzivna.}

\subsubsect{Splošne rekurzivne funkcije}
Herbrand je študiral, kako poljubno ŠT funkcijo definirati s sistemom enačb.

f je neznana funkcija, $g_1, g_2, \dots g_m$ pa znane %mestnost?
f-je in g-je poljubno vstavljamo kot argumente v druge, nato pa nekatere dobljene izraze izenačimo, potem pa če ima dobljeni sistem natanko eno rešitev za funkcijo f, potem je f rekurzivna.%preden je umrl v alpah je poslal tako pismo gödlu.. katerega leta?
Gödel je dodal dve dodatni zahtevi... f se sme na levi strani enačb sme pojaviti v obliki $f(g(...), g_k(...)$ %Herbrand je dovoljeval f(g...f...g), kar je preveč divje
f naj bo povsod na $N^k$ definirana (totalna).
Če se jo da zapisati s takim sistemom, je zapisana s standardnim sistemom. Tedaj je tak sistem za f z oznako $\varepsilon(f)$.

Kakšna so pravila za računanje vrednosti $f(n_1, n_2, \dots, n_k)$ iz $\varepsilon(f)$. %leta 1934 je ugotovil, da
Pravili sta samo 2.
1. v enačbi lahko vse pokave iste spremenljivke zamenjamo z istim naravnim številom???
2. v enačbi lahko pojave funkcije zamenjamo z njeno vrednostjo

Godel trdi: funkcija f za katero obstaja $\varepsilon(f)$ , se imenjue splošno rekurzivna%it's first def'd here.

\Povzetek{Algoritem po Herbrant-Gödlu(HG) je $\varepsilon(f)$.\\
	Računanje po HG je izračun vrednosti funkcije $f(n_1,\dots,n_k)$ iz $\varepsilon(f)$ z uporabo pravil 1,2.\\%izr. je, sta rekla... oz je samo Gödel reku... oh, snap :D
	Funkcija je izračunljiva po HG, če je splošno rekurzivna.}

\subsect{$\lambda$-račun}%1932,1933 Alonso Church
Imamo vhodni izraz, ki opisuje neko funkcijo f in argumente $n_1, \dots, n_k$.

Kako je funkcija opisana?
Začetni $\lambda$-term

Cilj: preoblikovati začetni $\lambda$-term v končni $\lambda$-term, tak, ki bo opisoval ravno vrednost $f(n_1, \dots, n_k)$
%this shit is exclusive :D

To preoblikovanje dosežemo z uporabo t.i. redukcij. Ta\\
bodisi preimenuje spremenljivko v $\lambda$-termu, $(\alpha)$
bodisi uporabi neko funkcijo nad njenimi argumenti.$(\beta)$ %a se da $\lambda$-term makro, ki bo pogledal nazaj in se pravilno sklonil? :D

$t0->t1->...->tK$
$f, n1, n2, ... nk$....$f(n_1, \dots, n_k)$

\Def{funkcija, ki jo je možno predstaviti in računati v tem lambda računu, taka funkcija je $\lambda$-definabilna}%fo'real!

\Povzetek{Algoritem po Churchu je $\lambda$-term.\\
	Računanje po Churchu je preoblikovanje začetnega $\lambda$-terma v končni $\lambda$-term z redukcijami.\\
	Funkcija je izračunljiva po Churchu, če je $\lambda$-definabilna.}

%zgledovanje po jeziku (glej gor)

\subsect{Postov Stroj}%1936, Post
%podoben turingovemu
%nadzorna enota
%trak s celicami
%okno
%+vrsta z znaki povezana v nadz enoto in iz nadzorne grejo lahko na konec vrste

Model je podoben Turingovemu stroju, z naslenjimi spremembami:
\begin{items}
\item s traku le bere znake
\item Uporablja vrsto znakov
\end{items}

Korak: prebere iz celice pod oknom znak in iz začetka vrste znak. na podlagi teh dveh znakov in stanja bo premaknil okno, nov znak dal na konec vrste in prešel v novo stanje.

%iz jezika? how? najprej: graf: opis problema pride v začetno vozlišče, nato po grafu potuje in se spreminja, dokler ne pride v končno stanje - rezultat. besedi se odreže prvi znak in glede na to se izbere pot v grafu, ali spremeni besedo, etc.. stroj to simulira.
%zgleda končen... kaj zdj? trak je končen, vrsta, stanja, ... %i dunno lol

\Povzetek{Algoritem po Postu je program Postovega stroja.\\
	Računanje po Postu je izvajanje programa Postovega stroja.\\
	Funkcija je izračunljiva po Postu, če njeno vrednost lahko izračuna Postov stroj.}

\subsect{Algoritmi Markova}%194..
Imamo abecedo $\Sigma$, končno zaporedje produkcij:
$x_1 \leftarrow y_1$
$x_2 \leftarrow y_2$
...
$x_n \leftarrow y_n$
$x,y \in \Sigma^*$%string v string

Produkija preoblikuje besedo tako da v tej besedi nadomesti skrajno levi pojav $x_i$ z $y_i$ %slikca beseda prej potem... x1->y1
%samo leva izpeljava, WTF?

Algoritem je zaporedje korakov, ki postopno preoblikuje začetno besedo v končno. V vsakem koraku se trenutna beseda preoblikuje s prvo (levo) možno produkcijo.

\Povzetek{Algoritem po Markovu je gramatika.\\
	Računanje po Markovu je preoblikovanje vhodne besede z dano gramatiko.\\
	Funkcija je izračunljiva po Markovu, če njeno vrednost računa kaka gramatika}

%poudarki: kaj imajo skupnega?
%razumno zmogljivi - končo različnih ukazov, vsak ukaz se izvede v končno korakih / času, v enem koraku se opravi končno veliko dela, učinek ukaza je predvidljiv(tudi nedeterminističnem... mjbi kvantni ne).
%potencialno neskončen spomin brez omejitev dostopa

%zdj pa neki za lepe sanje:
%vsi so se matral še kj več narest
\sect{Church-Turingova teza}
Church je postavil domnevo: ,,algoritem'' {\bf$\Longleftrightarrow$} algoritem po Churchu ($\lambda$-račun)\\%lol, kar sm js reku je algoritem :P glej sigma pri Churchu... Gödel ga je nekoliko zavrnil, vmes turing neodvisno do podobnega
Turing je postavil domnevo: ,,algoritem''  {\bf$\Longleftrightarrow$} algoritem po Turingu (Turingovi stroji)
\br
%Kdo je imel prav? oba, lol
%lol, trolla moje latex skille :)
Church-Turingova teza: ,,algoritem'' {\bf$\Longleftrightarrow$} algoritem po Turingu (ali po katerem izmed ostalih ekvivalentnih modelov)%bolj točno program turing stroja in turing zato, ker je najbl cute
%-----------------------predavanja 5-------------------------------
\br
Kaj je doprinos Church-Turingove teze?
%%1
algoritem%oblaček 
%<---> ni dokazano ampak vseen puščica
\fixme - krog... alg, kot so ga opisali (in okrog napisani T<=>P<=>GK<=>HG<=>M)

"algoritem" <---> program TS%okvir

%----

računanje%oblaček
%<--->
\fixme - krog... računanje, kot so ga opisali...% in okrog napisani T<=>P<=>GK<=>HG<=>M

"računanje" <---> delovanje TS%okvir

%----

izračunljiva funkcija%oblaček
%<--->
\fixme - krog... izr. funkcija, kot so jo opisali...% in okrog napisani T<=>P<=>GK<=>HG<=>M

"izračunljiva f" <---> f izračunljiva s TS%okvir

\Odmakni{Težava}{...}

\subsubsect{Težave s totalnimi funkcijami}
%$f:\mathbb{N}\rightarrow\mathbb{N}$%
Kako v splošnem dokazati, da je neka funkcija res totalna?\\
V najslabšem primeru, bi bilo treba preizkusiti za vsak $x\in A$, ali je funkcija pri tem $x$ definirana.%( pišemo: $f(x)\uparrow$ )\\
Če je A neskončen, ta način seveda ni končen.
Pojem izračunljivosti funkcije se tako opira na nek algoritmično težko določljiv pojem totalnosti.
%slikca dva kroga A, B... \forall x ... f(x)
\br
%%2
Po Church-Turingovi tezi je izračunljiva ... rekurziva funkcija %oz. vsaka, ki jo računa TS
\begin{items}
\item moč $N^k:N$ je c (moč realnih števil)%?
\item rekurzivnih funkcije je $\aleph_0$ (števno mnogo)
\item Vsako definira program TS, programov pa je števno mnogo.
\item ? ali je med vsemi funkcijami ($\mathbb{N}^\mathbb{N}$) možno najti tako, ki je izračunljiva, pa ni rekurzivna.
\item DA -- dokaz z diagonalizacijo:\\
\end{items}
\Trditev{Obstaja izračunljiva funkcija, ki ni rekurzivna.}
\Dokaz{Definicije funkcij so končna zaporedja.\\%(Trditev)
uredimo zaporedja po dolžini, enako dolga pa leksikografsko\\
$\Rightarrow$ lahko govorimo o prvem, drugem, ..., o $n$-tem programu TS. Zato lahko tudi prvi, drugi, ... n-ti rekurzivni funkciji.\\
označimo $n$-to rekurzivno funkcijo s $f_n$\\
definirajmo ......\\
$g(n, a_1,\dots, a_k) \mbox{ po def. } f_n(a_1, a_2, \dots, a_k)+1$, kjer $a_i\in \mathbb{N}$\\%označimo z *
funkcija je izračunljiva\\
algoritem je ....\\
....\\
ali je $g$ tudi rekurzivna\\
ali obstaja program TS, ki je izračuna.\\

predpostavka: $g$ je rekrivna\\
	Tedaj obstaja nek naravni $m$, da je $f_m = g$.\\%nti program po vrsti. označimo z **
	Poglejmo vrednost $g(m,m,\dots,m)$\\
	iz (*) sledi $g(m, m, \dots, m) = f_m(m, m, \dots, m)$\\
	iz (**) sledi $f_m(m, m, \dots, m) = g(m, m, \dots, m)$\\
	iz tega sledi $f_m(m, m, \dots, m) = f_m(m, m, \dots, m)+1$\\ %označimo z ***
	in pridemo v protislovje -- $g$ ni rekurzivna.\\%intuitivno smo sestavili funkcijo...
	torej obstaja funkcija, ki je izračunljiva in ni rekurzivna.\\% če gledamo po godlu... mogoče moramo dodati trem še kakšno pravilo za .. ali sestavljanje
	
	kaj sedaj?\\
	Ali naj dodajo začetne funkcije, ali pravila za dodajanje, če gledamo Godlov model\\%HG ali GK??
	Ne, pridemo v isto protislovje.\\

	Ali je to ovrglo CT tezo?\\
	Ne. Ugotovili so, da se je treba odpovedati zahtevi, da so funkcije le totalne. Dopustiti je treba tudi sestavljene parcialne.\\
	%pri parcialnih funkcijah f = f+1 lahko ni definirano in to je ok
	Takrat *** ni več nujno protislovje, saj je lahko $f_m(mmmm)\uparrow$.
}
\Povzetek{Funkcija je "izračunljiva" <---> f računa nek TS tam, kjer je definirana}
%rekurzivne -> parcialne rekurzivne... so izračunljive
%vpr: kako dobimo n-ti turingov stroj, pa da je totalen, ... obratno je nekako :)

\section{Univerzalni Turingov stroj}
%če bi lahko TS oštevilčil, bi lahko kodo stroja dal na vhod in bi TS računal s TS.
%Ideja je prišla od Godla: un grafek... ali je sistem popoln. ko je oštevilčil stvari, je lahko imel referenco in samo-referenco
\Ideja{Turingove stroje bi radi oštevilčili. \\
	Če bi imel vsak Turingov stroj svoj indeks, bi nek drug Turingov stroj lahko računal z drugimi stroji oz. z njihovimi ideksi.
	Kdaj je to koristno?}

\subsubsect{Kodiranje Turingovih strojev}
Kako poljuben Turingov stroj zakodirati z abecedo $\{0,1\}$?
Zadošča da zakodiramo program $\delta$ Turingovega stroja.%kj več je waste of time... sj verjamete :)
Naj bo $T=\langle Q,\Sigma,\Gamma,\delta,q_1,B_1,q_f \rangle$ poljuben stroj.%bomo samo delta, ostale se da razbrat ven
Če je $\delta(q_1,a_j)=\langle q_k, a_l, S_m \rangle$ ukaz programa $\delta$, ga zakodiramo kot:
	\[ K=0^i 1 0^j 1 0^k 1 0^l 1 0^m\]
Ko zakodiramo vseh R ukaov programa $\delta$ dobimo kode $K_1, K_2, \dots, K_r$ iz katerih bomo sestavili kodo Turingovega stroja:
	\[ <T> = 111 K_1 11 K_2 11 \dots 11 K_r 111\]%označimo z *
Na $<T>$ lahko gledamo kot da je dvojiški zapis nekega naravnega števila in to je indeks Turingovega stroja $T$.

Nekatera naravna števila niso indeksi TS, zato se dogovorimo: če naravno število nima oblike *, rečemo, da je indeks praznega Turingovega stroja (njegova $\delta$ je povsod nedefnirana -- takoj se ustavi in ne sprejme nobene besede)
Posledica: vsako naravno število, je indeks natanko enega Turingovega stroja.
Obratno ne velja. Isti Turingov stroj ima več indeksov (dodajamo nepotrebne in nesmiselne ukaze, pa je.)
\Trditev{Obstaja Turingov stroj, ki izračuna vse kar izračuna katerikoli drug Turingov stroj.}
\Dokaz{Stroj si zamislimo v grobem in intuitivno zapišemo njegov program. Skličemo se na CT tezo, ki nam zagotovi obstoj nekega konkretnega TS (ki opravlja ta algoritem)}%


Ideja stroja U:

\Odmakni{Trakovi}{
Vhodni trak - vsebuje vhodno besedo sestavljeno iz dveh delov:
\begin{items}
\item Kodo $<T>$ poljubnega Turingovega stroja.
\item Poljubno besedo $w \in \Sigma^*$
\end{items}
Delovni trak - sprva prazen. Stroj U .......
Pomožni trak - sprva prazen. Stroj U ga bo uporabljal za zapis tekočega stanja stroja T in za primerjanje tega stanja s končnim stanjem stroja T.
}

Program stroja U(intuitivo)
\begin{items}
\item Preveri, ali je vhod oblike $<T,\ w>$, kjer je T koda nekega Turingovega stroja. Če ni, se U ustavi (tudi T bi se)
\item Iz $<T>$ preberi kodo končnega stanja $<q_F>$, stroja T. in napisi $<q_1, q_f>$ na tretji trak.
\item Prepiši $w$ na delovni trak in postavi okno na začetek 
\item Denimo, da je na pomožnem traku nek par $<q_i, q_f>$ in da je v delovnem oknu znak $a$. Če je $q_i=q_f$, se stroj ustavi (tudi T bi se)
\item Na prvem traku poišči v <T> kodo ukaza, ki se začne z $\delta(q_i, a)=\dots$
\item Če je ne najdemo se U ustavi (tak T bi se ustavil)
\item Denimo, da najdena koda opisuje ukaz $\delta(q_i, a)=\langle q_, b, S \rangle$ ... na drugi trak zapiši b v ... premik v smeri S
\item Na pomožni trak namesto $<q_i,q_f>$ vpiši $<q_j,q_f>$, goto 4
\end{items}
\fixme slika: trije trakovi - vhodni(<T> w), delovni(wwww|a|wwww), pomožni(<qi><qF>)

To je bil intuitiven opis algoritma programa stroja U - algoritma. Po CT tezi lahko sestavimo pravi TS z vsemi podrobnostmi, ki izvaja delo opisanega stroja.
\[U=\langle Q_U,\Sigma_U,\Gamma_U,\delta_{U1},q_{U1},B,q_{Uf} \rangle  \]
To je univerzalni Turingov stroj.
%1996 je rus Yurii Rogozhin sestavil nekaj različic stroja U... 
% |Q_u|  |\Sigmau|
%   15    2
%   9     3
%   6     4  
%   5     5
%   4     6 (ta ima le 22 ukazov)
%   3     9
%   2    18
%kaj je wolfram tu s cellularnimi počel?
%v knjigi (5,2), kasneje (3,2)

\subsect{Pravi stroji, ki so univerzalni}
Naredimo nekaj sprememb:
Vsaka celica je neposredno dosegljiva prek naslova
Program naj bo na traku, ne v glavi
%von neumann itak
%trak ->pomilnik, celica pom lokacija, nadz enota CPE

%-----------------------predavanja 6-------------------------------
\sect{Reševanje računskih problemov}%ne osebnih, lol
Vrste računskih problemov lahko delimo na:
\begin{items}
\item Odločitvene - odgovorijo na dano vprašanje z DA ali NE %decision yes/no... ali ima graf Hamiltonov cikel, ali je št prašzevilo
\item Iskalne - sprašujejo po elementu množice, ki ima neko lastnost
\item Preštevalne - dajo število elementov v množici, ki imajo neko lastnost
\item Naštevalne - generirajo vse elemente v množici, ki imajo neko lastnost
\end{items}
Odločitevni problemi so najenostavnejši, zato se jim bomo tu bolj posvetili.

\subsect{Jezik odločitvenih problemov}
Problemu priredimo formalen jezik (množico besed nad neko abecedo).
\br
S $P$ označujemo odločitveni problem (npr. $P$=\Quote{Ali je število $n$ praštevilo?}).\\
Ko v problem $P$ vstavimo namesto $n$ nek konkretni podatek dobimo nalogo $p$. (npr. \Quote{Ali je 19871 praštevilo?}. Vsaka naloga ima odgovor DA ali NE, rečemo tudi, da je naloga pozitivna ali negativna.
V opisu naloge so vedno konkretni podatki.
Prek kodirne funkcije $\langle\rangle$ dobi vsaka naloga $p$ neko kodo $\langle p\rangle\in\Sigma^*$, ki jo razume nek Turingov stroj.
Naj bo $\langle \rangle :P\rightarrow \Sigma^*$. Zahtevamo, da je $\langle\rangle$ injektivna $(p \neq p' \Rightarrow \langle p \rangle \neq \langle p' \rangle$.%why... a ne bi blo kul met kr vse na isto?
Naj bo jezik problema P definiran kot:
\[ \mathcal{L}(P) \mbox{ po def. } \{ \langle p \rangle \in \Sigma^*\ |\ \mbox{p je pozitivna naloga problema P} \} \]

\fixme pravokotnik P s squigly črto po sredi... pozitivne/negativne naloge in pravokotnik Sig* s podmnožico L(P) in puščica iz pozitivnih v L prek kodirne funkcije <>

Torej naloga $p\in P$ je pozitivna, $\Leftrightarrow \langle p \rangle \in \mathcal{L}(P)$.
Računanje odgovora na nalogo p lahko zamenjamo z ugotavljanjem, ali je beseda $\langle p \rangle$v jeziku $\mathcal{L}(P)$.
%ne vemo a je na pozitivna al negativna... lažje je videt na drugi stran, če se presika v L(P)

\Def{Naj bo $P$ odločitveni problem. Pravimo, da je:
P je odločljiv, kadar je jezik problema $\mathcal{L}(P)$ rekurziven.
P je neodločljiv, kadar jezik problema $\mathcal{L}(P)$ ni rekurziven
P je poldločljiv, kadar je jezik problema $\mathcal{L}(P)$ Turingov(rekurzivno prešteven).%odločljivi, ampak se včasih ne ustavi
}
%problem smo prenesli na področje jezikov..
\subsect{Neodločljivi problemi}
%Turing 1936
Težave delajo stroji, ki se ne ustavijo.
Ali bi lahko za poljuben par stroja in besede, $\langle T,w \rangle$, preverili, ali se T(w) ustavi.
\Def{Problem ustavitve: $P_{\mathcal{K}_0}$ je odločitveni problem \Quote{Ali se Turingov stroj $T$ pri besedi $w$ ustavi?"}}
\Trditev{Problem ustavitve ni odločljiv.}
\Dokaz{Jezik problema je: $\mathcal{K}_0=\{ \langle T, w \rangle\ |\ T \mbox{ se pri w ustavi} \}$
Nekaj časa nas bo zanimal jezik $\mathcal{K} \subseteq \mathcal{K}_0$, ki ga dobimo iz $\mathcal{K}_0$, če za $w$ vzamemeo kar kodo stroja, torej $<T>$.
$\mathcal{K}=\{ T,T\ |\ T \mbox{ se pri <T> ustavi. } \}$
Temu jeziku pripada odločitveni problem $P_\mathcal{K}$ - \Quote{Ali se Turingov stroj ustavi nad lastno kodo?}.

\Lema{Problem $P_\mathcal{K}$ ni odločljiv.}
\Dokaz{Predpostavimo, da je množica $\mathcal{K}$ rekurzivna (torej, je njen problem odločljiv). Potem gotovo obstaja Turingov stroj $R$, ki ta jezik razpoznava. $\exists TS:R_\mathcal{K}$, ki za poljuben T odgovori $R(<T,T>)$

kjer je R(<T,T>)= DA, če se T ustavi nad <T> ... NE, če se ne ustavi.
%here comes the good/hard part
Sestavimo nov Turingov stroj $N$ s pomočjo domnevnega $R_\mathcal{K}$:
\fixme škatla N. vhod <T>,v škatli naredi <T,T>, preda kosmati (ne vemo če obstaja) škatli $R_\mathcal{K}$ z izhodi DA/NE... če DA ga vprašamo šeenkrat isto.. če ne, ne speljemo na izhod N
\Trditev{domnevni $R_\mathcal{K}$ napove prihodnost stroja T, N pa bo razgalil nesposobnost $R_\mathcal{K}$ pri tem napovedovanju na primeru T=N}
\Dokaz{\fixme <N> gre v <N,N>
%R_K vrne napačen odgovor, ker se <N> ne ustavi, če naj bi se ustavil in se ustavi, če naj se ne bi ustavil. P-p-p-protislovje.
Domnevni $R_\mathcal{K}$ ne bi rešil naloge p - \Quote{Ali se Turingov stroj $N$ pri vhodu $<N>$ ustavi?}
Sklep: K ni rekurziven jezik, zato $R_\mathcal{K}$ ni odločljiv problem.%problem, ki ni odločljiv!!
}
}%konec leme
Tudi $P_{\mathcal{K}_0}$ ni odločljiv, sicer bi bil zagotovo odločljiv tudi podproblem $P_\mathcal{K}$.
Sklep: Obstaja odločittveni problem, za katerega ni Turingovega stroja, ki bi ga vedno rešil.%let's call Church-Turing again....
Turingov stroj je po CT-tezi algoritem, torej za nekatere probleme ni algoritma, ki bi ga rešil.
%ok... what now... kaj je praktična posledica? nekaj primerov.
%kam tu paše dokazovanje pravilnosti? ja.
}
\subsect{Primeri nerešljivih problemov}
\fixme napol presekana množica - odločljivi/neodločljivi
\subsubsect{Problemi o Turingovih strojih}
Problem garača (angl. busy beaver):
Vzamemo Turingove stroje, ki imajo n nekončnih stanj. Takih strojev je končno mnogo. Garač je turingov stroj z natanko $n$ nekončnimi stanji, ki začne s praznim trakom in zapiše največ enic (od vseh takih strojev), preden se ustavi.
\Quote{Ali je Turingov stroj $T$, garač?}.
\br
Še nekaj primerov za ustavitev Turingovega stroja: \Quote{Ali se $T$ pri $w$ ustavi?}, \Quote{Ali se $T$ pri praznem vhodu ustavi?}, \Quote{Ali se $T$ pri vsakem vhodu ustavi?}, \Quote{Ali se dva stroja ustavita pri istih vhodih?}
\br
Razpoznavanje jezikov:\\
\Quote{Ali Turingov stroj $T$ razpoznava rekurziven jezik?},\\
\Quote{Ali Turingov stroj $T$ razpoznava regularen jezik?}

\subsubsect{Problemi o algoritmih in programih}
$P$ je problem, $<P>$ opis problema.\\
$A$ je algoritem, $<A>$ označuje program.\\
\Quote{Ali program $<A>$ rešuje problem $<P>$?}
\br
Pravimo, da je program $<A'>$ ekvivalenten $<A>$, če da za vsak vhod enako vrednost kot $<A>$.\\
\Quote{Ali obstaja program $<A'>$, ki je krajši in hkrati ekvivalenten $<A>$?}

\subsubsect{Problemi o izračunljivih funkcijah}
$\varphi:A\rightarrow B$ je izračunljiva funkcija.\\
\Quote{Ali ima $\varphi$ neprazno domeno?},\\
\Quote{Ali ima $\varphi$ neskončno domeno?},\\
\Quote{Ali ima $\varphi$ končno domeno?},\\
\Quote{Ali je $\varphi$ surjektivna?},\\
\Quote{Ali je $\varphi$ totalna?}

\subsubsect{Problemi iz matematike}
\Quote{Ali ima Diofantska enačba $p(x_1,x_2,\dots,x_n)$ celoštevilsko rešitev?} %glej na začetek poglavja
\br
Dana je množica matrik $\mathcal{M}=\{ M_1, M_2, \dots, M_n \}$. Vse matrike so reda $n\times n$ in imajo celoštevilske koeficiente.\\
\Quote{Ali je mogoče zmnožiti matrike $M_i$ tako, da dobimo ničelno matriko?}

\subsubsect{Problemi o gramatikah in jezikih}
%nahitro
\Quote{Ali je dana kontekstno-neodvisna gramatika dvoumna?},\\
\Quote{Ali sta dve kontekstno-neodvisni gramatiki ekvivalentni?}%recimo zanimivo za načrtovalce jezikov.

\subsubsect{Problemi matematične logike}
%tu je menda nek uvod, ki ga ne poznamo%what?
\Quote{Ali so vse formule predikatnega računa prvega reda odločljive?}

%zdj menda pridejo luštni problemi ^^
\subsubsect{Razni problemi}
Enakost besed: $E$ naj bo končna množica enačb nad besedami. npr. \\
1. bc=cba\\
2. ba=abc\\
3. ca=ac\\
Od tu lahko izpeljemo enakost abcc=cacacbaa\\%ne vem če je prav prepisano
\Quote{Ali iz $E$ sledi $u=v$?}
\br
Tlakovanje: Imamo končno množico tlakovcev $T=\{$\fixme križ-kraž kvadrati z različno pobarvanimi četrtinami $\}$. Radi bi tlakovali ravnino razdeljeno na kvadrate, tako, da se sosednja tlakovca vedno ujemata v barvi.%slikica :P
\Quote{Ali lahko tlakujemo vsak poligon v $\mathbb{Z}^2$?}\\
\Quote{Ali lahko tlakujemo pot v ravini od točke $A$ do $C$, s tem, da ne obiščemo točke $B$?}

\subsect{Dokazovanje neodločljivosti problemov}
Neodločljivost problema lahko dokazujemo z naslednjimi metodami:
\begin{items}
\item Neposredno dokazovanje %potrebujemo veliko intuicije. tako smo P_K dokazal
\item Dokazovanje s prevedbo %tako smo dokazali P_k_0
\item Dokazovanje z Riceovim izrekom %menda najlažja
\end{items}

\subsubsect{Dokazovanje s prevedbo}
Naj bo $Q$ odločitveni problem, za katerega sumimo, da je neodločljiv.%neuničljiv, lol :P
Dokazujemo v treh korakih:
\begin{items}
\item Izberemo nek problem $P$, ki ni odločljiv. %how do i? po feelingu menda
\item Dokažemo, da velja: če bi bil $Q$ odločljiv, bi bil tudi $P$ odločljiv.
\item Če prejšnji korak uspe lahko sklenemo da $Q$ ni odločljiv. %lol, modus tollens
\end{items}
V koraku 2 z domnevnim Turingovim strojem $R_Q$, je treba sestaviti Turingov stroj $R_P$, ki se vedno ustavi.
%slika od prej škaltla RLP... kosmata RLQ škatla notr

%-----------------------predavanja 7-------------------------------

\subsubsect{Dokazovanje z Riceovim izrekom}%1951 USA
\begin{items}
\item Za funkcije - Vsaka netrivialna lastnost izračunljivih funkcij je neodločljiva%parcialno rekuzivnih f %RI za funkcija
\item Za jezike - Vsaka netrivialna lastnost Turingovih jezikov je tudi neodločljiva
\end{items}
%kaj točno je lastnost, etc.
\Odmakni{Podrobneje}
{
Naj bo $L$ neka lastnost za funkcije in naj bo $\varphi$ poljubna izračunljiva funkcija.\\
\[P_L eq \mbox{\Quote{Ali ima $\varphi$ lastnost $L$?}}\]\\
\Def{Funkcijska lastnost $L$ je odločljiva, če je $P_L$ odločljiv.}
\Odmakni{?}{Kakšne smiselne lastnosti pa nas zanimajo?\\
Samo take lastnosti L, da so neodvisne od ...(=lg,TS,...), s ....... njihove vrednosti.
npr. \Quote{L eq \Quote{bodi totalna}}
\Def{Lastnost funkcij L je trivialna, če jo ima bodisi vsaka ali pa nobena funkcija.}
}
}
\subsubsect{Riceov prvi izrek za funkcije}
Lastnost izračunljivih funkcij je odločljiva $\Longleftrightarrow$ je ta lastnost trivialna.
\Odmakni{Slaba novica}{Problem $P_L$ bo odločljiv le za trivialne funkcijske lastnosti, ki navadno niso zanimive za obravnavo.}
\Odmakni{Dobra novica}{Ugotavljanje odločljivosti $P_L$ je enostaven, ker ga lahko nadomestimo z ugotavljanjem ali je ustrezna lastnost $L$ trivialna.}


\Primer{$P_L$ eq \Quote{Ali je $\varphi$ totalna?}\\
Preverimo:\\
Ali je lastnost smiselna? DA.\\
Ali je lastnost trivialna? NE.\\%ker obstajajo parcialne, poleg totalnih... in ravno zato tisto prej s totalnimi ni bilo kul
Torej, $P_L$ ni odločljiv problem.
}
\Primer{Ali ima $\varphi$ neprazno domeno?\\
Ali ima $\varphi$ končno domeno?\\
Ali ima $\varphi$ neskončno domeno?\\
Ali ima $\varphi$ pri vsaj enem argumentu vrednost 3?\\
Ali je $\varphi$ surjektivna/injektivna?\\
Ali je $\varphi$ definirana pri 2?\\%zakaj? pač določeni se ne ustavijo
Ali je $\varphi$ enaka drugi funkciji $\psi$?\\
%splošno vprašanje:kaj če bi naredil en zlepek? ... začne pisat neskončno if stavkov if p=p_i then Alg_i :P
%kaj pa če bi generirali rešitev sproti in jo preverili? .... tudi ne gre.
}
%stroj T_e, koda <T_e>, indeks stroja e
%T_e ima \psi_e, oz. lastno funkcijo \varphi
%\Theta\varphi=\{ x\ |\ \varphi=\psi_x\} - vsi programi, ki računajo \varphi... indeksna množica \varphi
%slika stroja trak z n 0, potem trak z m 0 ... f(n)=m je lastna funkcija stroja
%

\Dokaz{
Lastnost funkcij ... od ,,, \\
Naj bo $L=\{ \psi | \psi\mbox{ ima lastnost } L\}$.\\
Problem $P_L$ je sedaj vprašanje: $\varphi =? \mathcal{L}$.\\
Naj bo $\Theta\mathcal{L}=\{ \mbox{ vsi programi(indeksi Turingovih strojev), ki računajo funkcijo iz} \mathcal{L} \} = \cup_{\psi \in \mathcal{L}} \Theta\psi$.\\
Ker je po predpostavki lastnost L neodvisna od načina računanja funkcije, so v množici $\Theta\mathcal{L}$ bodisi vsi programi, ki računajo neko funkcijo $\varphi$, ali pa noben.\\
Zato je vprašanje ali je $\varphi\in?\mathcal{L}$ ekvivalentno vprašanju: $x\in?\Theta\mathcal{L}$, kjer je $x$ indeks poljubnega Turingovega stroja, ki računa funkcijo $\varphi$.\\
Torej: Problem $\varphi\in?\mathcal{L}$ oz. $P_L$ je odločljiv, $\Longleftrightarrow$ jezik $\Theta\mathcal{L}$ odločljiv.%tu sedaj vstopi Rice :)
\br
Rice je dokazal, da je $\Theta\mathcal{L}$ odločljiv $\Longleftrightarrow$ $\Theta\mathcal{L}$, bodisi $\emptyset$, ali pa $\mathbb{N}$. %torej vsi izračunajo, ali pa noben
%prejšnja leta drugi dokazi (brez indeksov, amapak daljši.. check 2007)
}
\Dokaz{
$\emptyset$ in $\mathbb{N}$ sta obe odločljivi, torej je taka tudi $\Theta\mathcal{L}$, če je enaka kateremu od njiju.\\%kaj pomeni ES in N sta odl.? Algoritem, ki preveri pripadnost.
Zato vzamemo, da $\Theta\mathcal{L}$ ni niti $\emptyset$, niti $\mathbb{N}$. Sledi: $\exists a,b: a\in\Theta\mathcal{L} \wedge b\in\overline{\Theta\mathcal{L}}$
Naj bo $\varphi_n$ povsod definirana funkcija.\\
..Ker je $n$ naraven, je bodisi v $\Theta\mathcal{L}$, bodisi izven.\\
Predpostavimo: $n\in\overline{\theta\mathcal{L}}$\\
..Naj bo $f$ funkcija, ki vsak $x\in\mathcal{K}$ preslika v $a$, vsak $x\in\overline{\mathcal{K}}$ pa v $n$.\\
Potem:$x\in\mathcal{K} \Longleftrightarrow f(x)\in\Theta\mathcal{L}$%tu je neka hitra prevedba :P
To pomeni: če bi bil $\Theta\mathcal{L}$ odločljiv, je tudi $\mathcal{K}$, torej $\Theta\mathcal{L}$ ni odločljiv.%šeeno malenkost imamo da dokažemo vse
Predpostavimo še: $n\in\Theta\mathcal{L}$ in dokažemo na analogen način.
}
%na kratko še za jezike... brez dokaza, phew.
\subsubsect{Riceov prvi izrek za jezike}
$L$ je lastnost, smiselna za jezike, $\mathcal{M}$ pa naj bo poljuben Turingov jezik.\\
Problem: $Q$ eq \Quote{Ali ima Turingov jezik $\mathcal{M}$ lastnost $L$?}.
\Def{$L$ je odločlvijv, če ke QL odločljiv problem}
\Def{$L$ je trivialna, če jo ima bodisi vsak Turingov jezik, ali pa noben}
Riceov izrek: Lastnost Turingovega jezika je odločljiva $\Longleftrightarrow$ lastnost je trivialna.\
\Primer{
\Quote{Ali Turingov jezik $\mathcal{M}$ vsebuje npr. besedo aabca?}\\
\Quote{Ali je Turingov jezik $\mathcal{M}$ enak Turingovemu jeziku $\mathcal{N}$?}\\
\Quote{Ali Turingov jezik $\mathcal{M}$ regularen?}
}
%-----------------------predavanja 8-------------------------------
\sect{Povzetek}
V prejšnjem poglavjo pri izračunljivosti nas je predvsem zanimalo:
\begin{items}
\item Kaj se da/ne da izračunati
\item Kaj lahko izračuna določen model računanja
\item Ni nas zanimala časovna in prostorska zatevnost računanja
\end{items}

Pri tem smo ugotovili:
\begin{items}
\item Obstajajo neizračunljivi(neodločljivi) problemi
\item Za te probleme ni splošnega algoritma, ki bi se vedno ustavil
\item Enako bi obveljalo če bi imeli neomejeno prostora/časa 
\end{items}

\fixme slika elipsa prerezana na pol -- odločljivi/neodločljivi(našteti... + načini dokazovanja). jih je neskončno mnogo

\subsect{Turingov stroj s prerokom}
Post, Kleene in drugi so se nato začeli spraševai, kaj bi pomenilo, če bi našli rešitev za enega izmed neodločljivih problemov.
Uvedli so Turingov stroj s prerokom, ki zna povedati ali je odgovor na odločitveni problem DA, NE, ali pa NEVEM.
Pojavljata se dve implementaciji:
\begin{items}
\item Dodamo tri dodatna stanja $q_DA, q_NE$ in $q_?$, v katera stroj preide po branju vhodne besede.
\item Imamo trak na katerem so zapisane vse rešitve za nek problem.
\end{items}
%Post... kaj če najdemo rešitev za enega od nodločljivih?
%TS s prerokom (oracle) ... ima 3 dodatna stanja q_? q_DA, q_NE
%ko prebere besedo, se premakne v eno izmed teh stanj.
%včsaih imamo trak z vsemi rešitvami...
%L(T^\mathcal{L}) = \{ w\ |\ za w se T^L ustavi v končnem stanju \}

\subsect{Polodločljivi jeziki glede na nek jezik}
\Def{Naj bo $\mathcal{M}$ nek jezik. Pravimo, da je $\mathcal{M}$ glede na $L$:\\
\begin{items}
\item Polodločljiv: če je $M=L(T^\mathcal{L})$ za nek $T^\mathcal{L}$
\item Rekurziven: če je $M=L(T^\mathcal{L})$ za nek $T^\mathcal{L}$ in se vedno ustavi.
\end{items}
}
\br
Tu lahko začnemo odgovarjati na vprašanje kaj bi pomenilo, če bi bil nek problem rešljiv.\\
Razredi relativne izračunljivosti:
\begin{items}
\item $\Sigma_1^0 \mbox{ po def. } \{ M\ |\ \mbox{M je r.e}\}$
\item $\Sigma_{n+1}^0 \mbox{ po def. } \{ M\ |\ \mbox{M je r.e. glede na nek jezik L iz prejšnjega razreda } \Sigma_n^0\}$
\item $\Delta_1^0 \mbox{ po def. } \{ M\ |\ \mbox{M je rekurzivnen} \}$
\item $\Delta_{n+1}^0 \mbox{po def}. \{ M\ |\ \mbox{M je rekurziven glede na nek jezik L iz prejšnjega razreda} \Sigma_n^0\}$%menda sigma...
\item $\Pi_n^0 \mbox{po def.} \{ M\ |\ \overline{M} \in \Sigma_n^0 \}$
\end{items}

Ugotovitve:\\%ugotovitve? rly?
$\mathcal{M} \in \Sigma_n^0 \Longleftrightarrow M=\{ \exists x_1 \forall x_2 \exists x_3 \dots Quant x_n R(w, x_1,\dots,x_n)\}$\\ %R je odločljiva relacija
$\mathcal{M} \in \Pi_n^0 \Longleftrightarrow M=\{ \forall x_1 \exists x_2 \forall x_3 \dots Quant x_n S(w, x_1,\dots,x_n)\}$\\ %za S nevem
%(menda neka zveza med aritmetiko in odločljivostjo)
%zgornji del slike razpade:
%\Delta_1^0
%  \Sigma_1^0
%  \Pi_1^0
%    \Delta_2^0
%      \Sigma_2^0
%      \Pi_2^0
\fixme spet eliplsa, delitev na $\Sigma \Delta \Pi$

Dobimo aritmetično hiearhijo: $\Sigma_1^0, \Delta_1^0, \Pi_1^0, \dots$
Torej, če bi bil nek $\Sigma_n^0$ rešljiv, bi bili rešljivi tudi $\Delta_n^0$, problemi na višjih nivojih pa še vedno ne.

Nekaj primerov in kam v hiearhijo spadajo:
\begin{items}
\item Problem ustavitve $\mathcal{K}_0 \in \Sigma_1^0$
\item Stroji, ki ne sprejmejo nobene besede $\in \Pi_1^0$
\item Vprašanje, ali TS razpoznava končen jezik $\in \Sigma_1^0$
\item Vprašanje, ali je funkcija totalna $in \Pi_2^0$
\end{items}
%REcimo, da imamo nek nerešljiv problem... kako poenostavimo?
%kaj je tisto ^0... če bi kvantificirali funkcije, bi delali s predikati 2. reda
%dobimo analitično hiearhijo

%lol, tukaj je čudovit pisan svet vseh možnih zadev..... ampak ni uporaben :)

%%@tole je CHAPTER
\section{Prostorska in časovna zahtevnost računanja}
%za vsak problem v spodnji polovici obstaja algoritem
%Toda: intuitivno lahko rešimo večje naloge ali bolj zapletene naloge... če je na voljo več računskega vira
%kako to intuicijo formalizirati?

%Aksiomatski: osnovni pojmi, aksiomi, pravila izpeljevanja .... razvijemo teorijo zahtevnosti
%Manuel Blum
%s strogim formalnim pristopom, včasih dobimo kaj presenteljvega (izrek o vrzeli gap tehorem)

%Preučujemo konkretne vire: prostor / čas (druge: green computing, vzporedno računanje - procesorji in čas, aproksimacijski algoritmi(čas, napaka), verjetnostni algoritmi(čas,verjetnost pravilne rešitve))

\Def{Prostorska zahtevnost: Dan je Turingov stroj $M$, z enim vhodnim trakom, na katerem je vhodna beseda omejena z mejnikoma za začetek/konec. Vhodni trak je namenjen le branju. Imamo še k>=1 delovnih trakov, ki so neskončni v eno smer.\\
%slika TS
}
\Def{Stroj M je Turingov s prostorsko omejitvijo, S(n), če za vsak vhod dolžine n obišče kvejemu S(n) celic na vsakem delovnem traku. Pravimo, da ima jezik L(M) stroja prostorsko omejitev/zahtevnost S(n)}
%Intuitivno: za odgovarjnje, ali je neka beseda v jeziku, zadošča prostor S(|w|) na vsakem izmed trakov
%Opombe: štejejo se le celice na delovnih trakovih: Razlog: radi bi ... 
% Vsak trak porabi vsaj eno celico na vsakem traku, torej S(N) je vsaj 1
% če sn počasi narašča, vzamemo max(1, |^S(n)^|)
% nameesto k>= 1 lahko uporabimo 1 trak z večimi sledmi %ampak 

\Primer{ $L= \{wcw^R | w \in (0+1)^*\}$ ima prostorsko zahtevnost $log(n)$(zaokroženo gor)
$\exists TS M$ s prostorsko omejitvijo ... tko, da je L=L(M).
Kakšen je M? 
%TS
% $ w c w^R $
%
% binarno število, ki ozanačuje lego v w
% označuje lego v w^R
% M šteje? levo-desno po vhosni besedi ... zrcalno ...
% zakroženo gor vse: log|w|=log{ n-1 \over 2} <= logn prostora
}

\Def{Časovna zahtevnost: dan je TS M s k>=1 trakovi, na enem je vhodna beseda. Vsak je neomejen v obe smeri.
%slika %vhod %.....
}
\Def{Stroj M je Turingov s časovno omejitvijo, T(n), če za vsak vhod dolžine n naredi kvečjemu T(n) korakov preden se ustavi. Pravimo, da ima jezik stroja L(M) časovno omejitev/zahtevnost T(n)}
%Opombe: predpostavljamo, da mora bit celotna vhodna beseda prebrana.
% čas bo T(n) = n + 1 za %%kako dobimo log čas? dunno, lol. problem modela
% ... T(n) .... (n+1,T(n))
\Primer{ $L=\{ w c w^R | w \in (0+1)^0 \}$
ker obstaja TS M z časovno zahtevnostjo n+1 z L=(M).
Kakšen je M?
%w c wr
%...
%w

}

Nedeterministična časovna in prostorska zahtevnost.\\
NDTS ima: 
 prostorsko zahtenost/omejitev S(n), če za vsak vhod dolžine n obstaja izračun, ki obišče <= S(n) celic(na ?vsakem delu traku)
 časovno zahtenost/omejitev T(n), če za vsak vhod dolžine n obstaja izračun, ki obišče <= T(n) korakov%iz tu izvira P=NP

Jezik L ima deterministično prostorsko zahtevnost/omejitev, S(n), če zanj obstaja deterministični turingov stroj ki ima prostorsko omejitev S(n)
Jezik L ima nedeterministično prostorsko zahtevnost/omejitev, S(n), če zanj obstaja nedeterministični turingov stroj ki ima prostorsko omejitev S(n)
Jezik L ima deterministično časovno zahtevnost/omejitev, T(n), če zanj obstaja deterministični turingov stroj ki ima časovno omejitev T(n)
Jezik L ima nedeterministično časovno zahtevnost/omejitev, T(n), če zanj obstaja nedeterministični turingov stroj ki ima časovno omejitev T(n)

Razredi zahtevnosti:
\Def{DSPACE(S(n)) po def \{ L | L ima deterministično prostorsko omejitev S(n) \} -- vsi jeziki, ki jih lahko det. razpoznavamo v S(n)}
\Def{NSPACE(S(n)) po def \{ L | L ima nedeterministično prostorsko omejitev S(n) \} -- vsi jeziki, ki jih lahko nedet. razpoznavamo v S(n)}
\Def{DTIME(S(n)) po def \{ L | L ima deterministično časovno omejitev S(n) \} -- vsi jeziki, ki jih lahko det. razpoznavamo v T(n)}
\Def{NTIME(S(n)) po def \{ L | L ima nedeterministično časovno omejitev S(n) \} -- vsi jeziki, ki jih lahko nedet. razpoznavamo v T(n)}

\Primer{
$L=\{ w c w^R|... \}$\\
$L\in DSPACE(log(n))$
$L\in DTIME(n)$
}
%bomo pokazal iz kje pride podlaga O notacije
%-----------------------predavanja 9-------------------------------
\subsect{Osnovne lastnosti prostorske zahtevnosti}
\subsubsect{Linearno stiskanje oz. krajšanje trakov}
Tračna abeceda je končna, a poljubno velika.
\Ideja{Več zaporednih vrednosti na traku zamenjamo z znaki neke nove abecede}
%slika traku 011011
%slika traku 1 2 3
Tako lahko vedno zmanjšamo število celic za konstantni faktor.\\%...ponovil razlago S(n)
Pri prostorski omejitvi $S(n)$, nas zanima le njen velikostni razred. (Ki ga lahko opišemo z notacijo z O, $\Theta$ in $\Omega$.)

\Izrek{Če za jezik $L$ obstaja tračni Turingov stroj, s prostorsko omejitvijo $S(n)$, potem za $L$ obstaja $k$-tračni Turingov stroj s konstantno prostorsko omejitvijo $c>0$: $c*S(n)$}%kaj je c? hitrost svetlobe ni, lol
%opomba: menda je kul, da je c lahko na (0,1)
\Dokaz{Naj bo $M_1$ Turingov stroj, s prostorsko omejitvijo $S(n)$ in $L=L(M_1)$, $c\in(0,1)$.\\
Sestavimo Turingov stroj $M_2$, ki simulira stroj $M_1$, tako da:\\
\begin{items}
\item V eni celici $M_2$ hrani $r$ zaporednih celic $M_1$ %r bomo kasneje
\item Nadzorna enota stroja $M_2$ si beleži katero od r celic bi gledal $M_1$ in se primerno obnaša.
\end{items}
Pri simulaciji stroja $M_1$, $M_2$ obišče kvečjemu $\lceil {S(n) \over r} \rceil$.\\
Določimo $r$: Naj bo $r$ tak, da je ${1 \over r}={c \over 2}$, torej $r={2 \over c}$.\\
Če je:
\begin{items}
\item $S(n) \geq r$, je $\lceil {S(n) \over r}\rceil = \lceil {c*S(n) \over 2}\rceil = c*S(n)$
\item $S(n) < r$, ima $M_2$ vse shranjeno v eni svoji celici in uporabi le to celico.
\end{items}
Stroj $M_2$ razpoznava $L$ in ima prostorsko omejitev $c*S(n)$.
}
%Opomba: naj bo $d>1$, potem velja: DSPACE($S(n)$) \subseteq{obrnjen} DSPACE($d*S(n)$), torej kar lahko izračunamo na S(n), lahko tudi na $d*S(n)$
%velja tudi obratno (vzemi $c = {1 \over d$)
\Posledica{ 
Velja DSPACE($S(n)$)=DSPACE($c*S(n)$) za $\forall c>0$.\\
S spreminjanjem prostorske omejitve ne pridobimo na razpoznavni moči.
%vprašanje: ampak to za realne računalnike itak ne velja, ker so binarni... jup.
Enako velja tudi za nedeterministično računanje: NSPACE($S(n)$)=NSPACE($c*S(n)$) za $\forall c>0$.\\
\subsubsect{Odpravljanje trakov}
Ali, ter za kakšno ceno za prostorsko zahtevnost, lahko $k$ delovnih trakov nadomestimo z enim samim?
\Ideja{$k$ trakov nadomestimo z enim $2k$-slednim trakom}%kot v prejšnjem poglavju pri dokazu večtračni TS = osnovni
%slike večtračni => večsledni, enako kot tam zgoraj.
\Izrek{Če je $L$ jezik $k$-tračnega Turingovega stroja, s prostorsko omejitvijo $S(n)$, je taka tudi omejitev eno-tračnega Turingovega stroja.}

\subsect{Osnovne lastnosti časovne zahtevnosti}
\subsubsect{Linearno stiskanje, oz. krajšanje trakov}
Množica stanj je omejena, a poljubno velika.
\Ideja{Nekaj zaporednih stanj med računanjem nadomestimo z enim novim stanjem iz neke nove množice stanj}
Tako lahko vedno zmanjšamo število korakov za konstantni faktor.\\
Tudi pri časovni omejitvi $T(n)$, nas zanima le velikostni razred. (Ki ga lahko opišemo z notacijo z O, $\Theta$ in $\Omega$.)
\Odmakni{Priprava}{
\Def{Naj bo $f:\mathbb{N}\rightarrow\mathbb{N}$ funkcija, kjer velja:\\
	$sup(f(n))_{n\rightarrow\infty} \mbox{ po def } lim_{n\rightarrow\infty} (LUB\{ f(n), f(n+1), \dots \})$ %lowest upper bound e
	$inf(f(n))_{n\rightarrow\infty} \mbox{ po def } lim_{n\rightarrow\infty} (GLB\{ f(n), f(n+1), \dots \})$ %greatest lower bound
}
\Primer{ 
Naj bo $f(n)={1 \over n}$, če je $n$ sod, ter $f(n)=n$, če je $n$ lih.\\%%@tisto z matrix/cases... to je ugly zapis
% tabela
% n   | 1  2  3 4 5 6 ....      => sup fn = inf zaradi lihih arg
% f(n)| 1 1/2 3 ....               inf fn = 0  zaradi sodih arg.
%	Naj bo f(n) = n/n+1
% tabela
% n   | 1  2  3 4 5 6 ....      => sup fn = 1
% f(n)| 1/2 ....                   inf fn = 1 
\fixme 
}
\Velja{ 
	Če $f(n)$ konvergira, je limita enaka $sup_{n\rightarrow\infty} f(n)$ in $inf_{n\rightarrow\infty} f(n)$.
}
}
\Izrek{ 
	Če za jezik $L$ obstaja $k$-tračni Turingov stroj s časovno omejitvjo $T(n)$, potem za $L$ obstaja $k$-tračni Turingov stroj, s časovno omejitvijo $c*T(n)$, za $\forall c>0$, pod pogojem, da je $k>1$ in $inf_{n\leftarrow\infty} {T(n) \over n} = \infty$.
}
%Opombe: zahteva, da je $inf=\infty$, pomeni, da časovna omejitev $T(n)$ v vsakem primeru (za vsako dolžino vhoda) narašča vsaj malo hitreje od $n$. Torej, za branje vhoda mora biti vsaj malo korakov na voljo za izračun.
%Dokaz: Glej HU, QED, lol
\Posledica{ 
	DTIME($T(n)$)=DTIME($c*T(n)$).\\
	Torej, razred jezikov, ki jih lahko razpoznamo v času $T(n)$, ostane enak, če ga pomnožimo z kako konstanto $c>0$ (če je $inf_{n\leftarrow\infty} {T(n) \over n} = \infty$).
}
Kaj pa če je $inf_{n\leftarrow\infty} {T(n) \over n} < \infty$?\\
Če je $T(n)=d*n, d>1$(Torej, da imamo vsaj nekaj korakov časa za računanje), je $inf_{n\leftarrow\infty} {T(n) \over n} = d$ in ne vemo, ali velja zgornja posledica. Bilo bi čudno, če ne bi veljalo podobno, saj imamo $d$-krat več časa.
\Izrek{ 
	Če za jezik $L$ obstaja $k$-tračni Turingov stroj s časom $d*n, d>1$ in je $k>1$, potem za jezik za $\forall\varepsilon>0$ obstaja $k$-tračni Turingov stroj, s časovno omejitvijo $(1+\varepsilon)*n$
}
\Posledica{
	DTIME($d*n$)=DTIME($(1+\varepsilon)*n$) za poljubni konstanti $d>1$ in $\varepsilon>0$.
}
Kaj pa če bi $T(n)$ naraščal počasneje od $d*n$?\\
Tedaj bi imeli $inf_{n\leftarrow\infty} {T(n) \over n} = 0$ %kar je precej manjše od neskončno, lol
 in bi za take funkcije tisti zgornji izrek ne veljal.% I call that pulling an Andy :P
\br
Tudi za NTIME velja podobno:\\
	NTIME($T(n)$) = NTIME($c*T(n)$), za $c>0$\\%morda še nek copy paste nekaj od zgoraj pri DTIME
	NTIME($d*n$) = DTIME($(1+\varepsilon)*n$) za poljubni konstanti $d>1$ in $\varepsilon>0$
\subsubsect{Odpravljanje trakov}
%vse dela tudi neodvisno od modela Turingovega stroja
Ali, ter za kakšno ceno za časovno zahtevnost, lahko $k>1$ delovnih trakov nadomestimo z enim samim?
\Primer{
	$L=\{ ww^R\ |\ w\in\{0,1\}^* \}$\\%menda smo že imel na začetku poglavja
	Če je $k=2$, razpoznamo $L$ v linearnem času.\\
	Če je $k=1$ \\% levo-desno-levo....
	Časovna zahtevnost je reda $\Theta(n^2)$
}
Torej, z zmanjšanjem števila trakov na enega, se zahtevnost poveča s kvadratom.\\
\Trditev{To je največja možna upočasnitev pri prehodu s $k$-trakov na en trak.}
\Izrek{ 
	Če je $L\in$DTIME($T(n)$) za $k>1$-tračnem Turingovem stroju,
potem je $L\in$ DTIME($T(n)^2$) na eno-tračnem Turingovem stroju.
}
Torej $L$ zagotovo lahko rešimo v $T(n)^2$.\\
Enako velja tudi za nedeterministične stroje.
%note:lfloor, lceil za one zaokrožene
\br
Kaj pa, če se omejimo le na dva delovna traka (iz nekega $k>2$-tračnega stroja).\\
Tudi tukaj lahko pride do upočasnitve, a le za faktor $\log T(n)$.\\
\Izrek{Če je $L\in$DTIME($T(n)$) na $k>2$-tračnem Turingovem stroju, potem je $L\in$DTIME($T(n)*\log T(n)$) na dvotračnem Turingovem stroju.}
Analogno velja za nedeterministične stroje.}

\end{document}
